   1               		.file	"xboot.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 395               	.global	get_char
 397               	get_char:
   1:xboot.c       **** /************************************************************************/
   2:xboot.c       **** /* XBoot Extensible AVR Bootloader                                      */
   3:xboot.c       **** /*                                                                      */
   4:xboot.c       **** /* tested with ATXMEGA64A3, ATXMEGA128A1, ATXMEGA256A1, ATXMEGA32A4     */
   5:xboot.c       **** /*                                                                      */
   6:xboot.c       **** /* xboot.c                                                              */
   7:xboot.c       **** /*                                                                      */
   8:xboot.c       **** /* Alex Forencich <alex@alexforencich.com>                              */
   9:xboot.c       **** /*                                                                      */
  10:xboot.c       **** /* Copyright (c) 2010 Alex Forencich                                    */
  11:xboot.c       **** /*                                                                      */
  12:xboot.c       **** /* Permission is hereby granted, free of charge, to any person          */
  13:xboot.c       **** /* obtaining a copy of this software and associated documentation       */
  14:xboot.c       **** /* files(the "Software"), to deal in the Software without restriction,  */
  15:xboot.c       **** /* including without limitation the rights to use, copy, modify, merge, */
  16:xboot.c       **** /* publish, distribute, sublicense, and/or sell copies of the Software, */
  17:xboot.c       **** /* and to permit persons to whom the Software is furnished to do so,    */
  18:xboot.c       **** /* subject to the following conditions:                                 */
  19:xboot.c       **** /*                                                                      */
  20:xboot.c       **** /* The above copyright notice and this permission notice shall be       */
  21:xboot.c       **** /* included in all copies or substantial portions of the Software.      */
  22:xboot.c       **** /*                                                                      */
  23:xboot.c       **** /* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,      */
  24:xboot.c       **** /* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF   */
  25:xboot.c       **** /* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                */
  26:xboot.c       **** /* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  */
  27:xboot.c       **** /* BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   */
  28:xboot.c       **** /* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN    */
  29:xboot.c       **** /* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE     */
  30:xboot.c       **** /* SOFTWARE.                                                            */
  31:xboot.c       **** /*                                                                      */
  32:xboot.c       **** /************************************************************************/
  33:xboot.c       **** 
  34:xboot.c       **** #include "xboot.h"
  35:xboot.c       **** 
  36:xboot.c       **** #ifdef USE_INTERRUPTS
  37:xboot.c       **** volatile unsigned char comm_mode;
  38:xboot.c       **** 
  39:xboot.c       **** volatile unsigned char rx_buff0;
  40:xboot.c       **** volatile unsigned char rx_buff1;
  41:xboot.c       **** volatile unsigned char rx_char_cnt;
  42:xboot.c       **** 
  43:xboot.c       **** volatile unsigned char tx_buff0;
  44:xboot.c       **** volatile unsigned char tx_char_cnt;
  45:xboot.c       **** #else
  46:xboot.c       **** unsigned char comm_mode;
  47:xboot.c       **** #endif // USE_INTERRUPTS
  48:xboot.c       **** 
  49:xboot.c       **** // Main code
  50:xboot.c       **** int main(void)
  51:xboot.c       **** {
  52:xboot.c       ****         ADDR_T address = 0;
  53:xboot.c       ****         unsigned char in_bootloader = 0;
  54:xboot.c       ****         unsigned char val = 0;
  55:xboot.c       ****         int i, j, k;
  56:xboot.c       ****         void (*reset_vect)( void ) = 0x000000;
  57:xboot.c       ****         
  58:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
  59:xboot.c       ****         unsigned short devid_bit;
  60:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
  61:xboot.c       ****         
  62:xboot.c       ****         comm_mode = MODE_UNDEF;
  63:xboot.c       ****         
  64:xboot.c       ****         #ifdef USE_INTERRUPTS
  65:xboot.c       ****         rx_char_cnt = 0;
  66:xboot.c       ****         tx_char_cnt = 0;
  67:xboot.c       ****         #endif // USE_INTERRUPTS
  68:xboot.c       ****         
  69:xboot.c       ****         // Initialization section
  70:xboot.c       ****         // Entry point and communication methods are initialized here
  71:xboot.c       ****         // --------------------------------------------------
  72:xboot.c       ****         
  73:xboot.c       ****         #ifdef USE_32MHZ_RC
  74:xboot.c       ****         #if (F_CPU != 32000000L)
  75:xboot.c       ****         #error F_CPU must match oscillator setting!
  76:xboot.c       ****         #endif
  77:xboot.c       ****         #ifdef __AVR_XMEGA__
  78:xboot.c       ****         OSC.CTRL |= OSC_RC32MEN_bm; // turn on 32 MHz oscillator
  79:xboot.c       ****         while (!(OSC.STATUS & OSC_RC32MRDY_bm)) { }; // wait for it to start
  80:xboot.c       ****         CCP = CCP_IOREG_gc;
  81:xboot.c       ****         CLK.CTRL = CLK_SCLKSEL_RC32M_gc;
  82:xboot.c       ****         #ifdef USE_DFLL
  83:xboot.c       ****         DFLLRC32M.CTRL = DFLL_ENABLE_bm;
  84:xboot.c       ****         #endif // USE_DFLL
  85:xboot.c       ****         #endif // __AVR_XMEGA__
  86:xboot.c       ****         #else
  87:xboot.c       ****         #if (F_CPU != 2000000L)
  88:xboot.c       ****         #error F_CPU must match oscillator setting!
  89:xboot.c       ****         #endif
  90:xboot.c       ****         #ifdef __AVR_XMEGA__
  91:xboot.c       ****         #ifdef USE_DFLL
  92:xboot.c       ****         DFLLRC2M.CTRL = DFLL_ENABLE_bm;
  93:xboot.c       ****         #endif // USE_DFLL
  94:xboot.c       ****         #endif // __AVR_XMEGA__
  95:xboot.c       ****         #endif
  96:xboot.c       ****         
  97:xboot.c       ****         #ifdef NEED_INTERRUPTS
  98:xboot.c       ****         // remap interrupts to boot section
  99:xboot.c       ****         CCP = CCP_IOREG_gc;
 100:xboot.c       ****         #ifdef USE_INTERRUPTS
 101:xboot.c       ****         PMIC.CTRL = PMIC_IVSEL_bm | PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
 102:xboot.c       ****         #else
 103:xboot.c       ****         PMIC.CTRL = PMIC_IVSEL_bm;
 104:xboot.c       ****         #endif // USE_INTERRUPTS
 105:xboot.c       ****         #endif // NEED_INTERRUPTS
 106:xboot.c       ****         
 107:xboot.c       ****         #ifdef USE_LED
 108:xboot.c       ****         // Initialize LED pin
 109:xboot.c       ****         LED_PORT.DIRSET = (1 << LED_PIN);
 110:xboot.c       ****         #if LED_PIN_INV
 111:xboot.c       ****         LED_PORT.OUTCLR = (1 << LED_PIN);
 112:xboot.c       ****         #else
 113:xboot.c       ****         LED_PORT.OUTSET = (1 << LED_PIN);
 114:xboot.c       ****         #endif // LED_PIN_INV
 115:xboot.c       ****         #endif // USE_LED
 116:xboot.c       ****         
 117:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 118:xboot.c       ****         #ifdef USE_ATTACH_LED
 119:xboot.c       ****         // Initialize ATTACH_LED
 120:xboot.c       ****         ATTACH_LED_PORT.DIRSET = (1 << ATTACH_LED_PIN);
 121:xboot.c       ****         #if ATTACH_LED_INV
 122:xboot.c       ****         ATTACH_LED_PORT.OUTSET = (1 << ATTACH_LED_PIN);
 123:xboot.c       ****         #else
 124:xboot.c       ****         ATTACH_LED_PORT.OUTCLR = (1 << ATTACH_LED_PIN);
 125:xboot.c       ****         #endif // ATTACH_LED_INV
 126:xboot.c       ****         #endif // USE_ATTACH_LED
 127:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 128:xboot.c       ****         
 129:xboot.c       ****         #ifdef USE_ENTER_PIN
 130:xboot.c       ****         // Make sure it's an input
 131:xboot.c       ****         ENTER_PORT.DIRCLR = (1 << ENTER_PIN);
 132:xboot.c       ****         #if ENTER_PIN_PUEN
 133:xboot.c       ****         // Enable bootloader entry pin pullup
 134:xboot.c       ****         ENTER_PIN_CTRL = 0x18;
 135:xboot.c       ****         #endif // ENTER_PIN_PUEN
 136:xboot.c       ****         #endif // USE_ENTER_PIN
 137:xboot.c       ****         
 138:xboot.c       ****         #ifdef USE_UART
 139:xboot.c       ****         // Initialize UART
 140:xboot.c       ****         uart_init();
 141:xboot.c       ****         #endif // USE_UART
 142:xboot.c       ****         
 143:xboot.c       ****         #ifdef USE_I2C
 144:xboot.c       ****         // Initialize I2C interface
 145:xboot.c       ****         i2c_init();
 146:xboot.c       ****         
 147:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 148:xboot.c       ****         I2C_AUTONEG_PORT.DIRCLR = (1 << I2C_AUTONEG_PIN);
 149:xboot.c       ****         I2C_AUTONEG_PORT.OUTCLR = (1 << I2C_AUTONEG_PIN);
 150:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 151:xboot.c       ****         
 152:xboot.c       ****         #endif // USE_I2C
 153:xboot.c       ****         
 154:xboot.c       ****         #ifdef USE_FIFO
 155:xboot.c       ****         // Initialize FIFO
 156:xboot.c       ****         fifo_init();
 157:xboot.c       ****         #endif // USE_FIFO
 158:xboot.c       ****         
 159:xboot.c       ****         // --------------------------------------------------
 160:xboot.c       ****         // End initialization section
 161:xboot.c       ****         
 162:xboot.c       ****         // One time trigger section
 163:xboot.c       ****         // Triggers that are checked once, regardless of
 164:xboot.c       ****         // whether or not USE_ENTER_DELAY is selected
 165:xboot.c       ****         // --------------------------------------------------
 166:xboot.c       ****         
 167:xboot.c       ****         
 168:xboot.c       ****         
 169:xboot.c       ****         // --------------------------------------------------
 170:xboot.c       ****         // End one time trigger section
 171:xboot.c       ****         
 172:xboot.c       **** #ifdef USE_ENTER_DELAY
 173:xboot.c       ****         k = ENTER_BLINK_COUNT*2;
 174:xboot.c       ****         j = ENTER_BLINK_WAIT;
 175:xboot.c       ****         while (!in_bootloader && k > 0)
 176:xboot.c       ****         {
 177:xboot.c       ****                 if (j-- <= 0)
 178:xboot.c       ****                 {
 179:xboot.c       ****                         #ifdef USE_LED
 180:xboot.c       ****                         LED_PORT.OUTTGL = (1 << LED_PIN);
 181:xboot.c       ****                         #endif // USE_LED
 182:xboot.c       ****                         j = ENTER_BLINK_WAIT;
 183:xboot.c       ****                         k--;
 184:xboot.c       ****                 }
 185:xboot.c       **** #else // USE_ENTER_DELAY
 186:xboot.c       ****                 // Need a small delay when not running loop
 187:xboot.c       ****                 // so we don't accidentally enter the bootloader
 188:xboot.c       ****                 // on power-up with USE_ENTER_PIN selected
 189:xboot.c       ****                 asm("nop");
 190:xboot.c       ****                 asm("nop");
 191:xboot.c       ****                 asm("nop");
 192:xboot.c       ****                 asm("nop");
 193:xboot.c       **** #endif // USE_ENTER_DELAY
 194:xboot.c       ****                 
 195:xboot.c       ****                 // Main trigger section
 196:xboot.c       ****                 // Set in_bootloader here to enter the bootloader
 197:xboot.c       ****                 // Checked when USE_ENTER_DELAY is selected
 198:xboot.c       ****                 // --------------------------------------------------
 199:xboot.c       ****                 
 200:xboot.c       ****                 #ifdef USE_ENTER_PIN
 201:xboot.c       ****                 // Check entry pin state
 202:xboot.c       ****                 if ((ENTER_PORT.IN & (1 << ENTER_PIN)) == (ENTER_PIN_STATE ? (1 << ENTER_PIN) : 0))
 203:xboot.c       ****                         in_bootloader = 1;
 204:xboot.c       ****                 #endif // USE_ENTER_PIN
 205:xboot.c       ****                 
 206:xboot.c       ****                 #ifdef USE_ENTER_UART
 207:xboot.c       ****                 // Check for received character
 208:xboot.c       ****                 #ifdef __AVR_XMEGA__
 209:xboot.c       ****                 #ifdef ENTER_UART_NEED_SYNC
 210:xboot.c       ****                 if (uart_char_received() && (uart_cur_char() == CMD_SYNC))
 211:xboot.c       ****                 #else // ENTER_UART_NEED_SYNC
 212:xboot.c       ****                 if (uart_char_received())
 213:xboot.c       ****                 #endif // ENTER_UART_NEED_SYNC
 214:xboot.c       ****                 {
 215:xboot.c       ****                         in_bootloader = 1;
 216:xboot.c       ****                         comm_mode = MODE_UART;
 217:xboot.c       ****                 }
 218:xboot.c       ****                 #endif // __AVR_XMEGA__
 219:xboot.c       ****                 
 220:xboot.c       ****                 #endif // USE_ENTER_UART
 221:xboot.c       ****                 
 222:xboot.c       ****                 #ifdef USE_ENTER_I2C
 223:xboot.c       ****                 // Check for address match condition
 224:xboot.c       ****                 if (i2c_address_match())
 225:xboot.c       ****                 {
 226:xboot.c       ****                         in_bootloader = 1;
 227:xboot.c       ****                         comm_mode = MODE_I2C;
 228:xboot.c       ****                 }
 229:xboot.c       ****                 #endif // USE_ENTER_I2C
 230:xboot.c       ****                 
 231:xboot.c       ****                 #ifdef USE_ENTER_FIFO
 232:xboot.c       ****                 // Check for received character
 233:xboot.c       ****                 #ifdef __AVR_XMEGA__
 234:xboot.c       ****                 #ifdef ENTER_FIFO_NEED_SYNC
 235:xboot.c       ****                 if (fifo_char_received() && (fifo_cur_char() == CMD_SYNC))
 236:xboot.c       ****                 #else // ENTER_FIFO_NEED_SYNC
 237:xboot.c       ****                 if (fifo_char_received())
 238:xboot.c       ****                 #endif // ENTER_FIFO_NEED_SYNC
 239:xboot.c       ****                 {
 240:xboot.c       ****                         in_bootloader = 1;
 241:xboot.c       ****                         comm_mode = MODE_FIFO;
 242:xboot.c       ****                 }
 243:xboot.c       ****                 #endif // __AVR_XMEGA__
 244:xboot.c       ****                 
 245:xboot.c       ****                 #endif // USE_ENTER_FIFO
 246:xboot.c       ****                  
 247:xboot.c       ****                 // --------------------------------------------------
 248:xboot.c       ****                 // End main trigger section
 249:xboot.c       ****                 
 250:xboot.c       **** #ifdef USE_ENTER_DELAY
 251:xboot.c       ****         }
 252:xboot.c       **** #endif // USE_ENTER_DELAY
 253:xboot.c       ****         
 254:xboot.c       ****         #ifdef USE_INTERRUPTS
 255:xboot.c       ****         // Enable interrupts
 256:xboot.c       ****         sei();
 257:xboot.c       ****         #endif // USE_INTERRUPTS
 258:xboot.c       **** 
 259:xboot.c       ****         #ifdef USE_WATCHDOG
 260:xboot.c       ****         WDT_EnableAndSetTimeout();
 261:xboot.c       ****         #endif // USE_WATCHDOG
 262:xboot.c       **** 
 263:xboot.c       ****         // Main bootloader        
 264:xboot.c       ****         while (in_bootloader) {
 265:xboot.c       ****                 #ifdef USE_LED
 266:xboot.c       ****                 LED_PORT.OUTTGL = (1 << LED_PIN);
 267:xboot.c       ****                 #endif // USE_LED
 268:xboot.c       ****                 
 269:xboot.c       ****                 val = get_char();
 270:xboot.c       **** 
 271:xboot.c       ****                 #ifdef USE_WATCHDOG
 272:xboot.c       ****                 WDT_Reset();
 273:xboot.c       ****                 #endif // USE_WATCHDOG
 274:xboot.c       **** 
 275:xboot.c       ****                 // Main bootloader parser
 276:xboot.c       ****                 // check autoincrement status
 277:xboot.c       ****                 if (val == CMD_CHECK_AUTOINCREMENT)
 278:xboot.c       ****                 {
 279:xboot.c       ****                         // yes, it is supported
 280:xboot.c       ****                         send_char(REPLY_YES);
 281:xboot.c       ****                 }
 282:xboot.c       ****                 // Set address
 283:xboot.c       ****                 else if (val == CMD_SET_ADDRESS)
 284:xboot.c       ****                 {
 285:xboot.c       ****                         // Read address high then low
 286:xboot.c       ****                         address = get_2bytes();
 287:xboot.c       ****                         // acknowledge
 288:xboot.c       ****                         send_char(REPLY_ACK);
 289:xboot.c       ****                 }
 290:xboot.c       ****                 // Extended address
 291:xboot.c       ****                 else if (val == CMD_SET_EXT_ADDRESS)
 292:xboot.c       ****                 {
 293:xboot.c       ****                         // Read address high then low
 294:xboot.c       ****                         //address = ((ADDR_T)get_char() << 16) | get_2bytes();
 295:xboot.c       ****                         asm volatile (
 296:xboot.c       ****                                 "call get_char"    "\n\t"
 297:xboot.c       ****                                 "mov  %C0,r24"     "\n\t"
 298:xboot.c       ****                                 "call get_2bytes"  "\n\t"
 299:xboot.c       ****                                 "clr  %D0"         "\n\t"
 300:xboot.c       ****                                 : "=r" (address)
 301:xboot.c       ****                                 :
 302:xboot.c       ****                         );
 303:xboot.c       ****                         
 304:xboot.c       ****                         // acknowledge
 305:xboot.c       ****                         send_char(REPLY_ACK);
 306:xboot.c       ****                 }
 307:xboot.c       ****                 // Chip erase
 308:xboot.c       ****                 else if (val == CMD_CHIP_ERASE)
 309:xboot.c       ****                 {
 310:xboot.c       ****                         // Erase the application section
 311:xboot.c       ****                         SP_EraseApplicationSection();
 312:xboot.c       ****                         // Wait for completion
 313:xboot.c       ****                         #ifdef USE_WATCHDOG
 314:xboot.c       ****                         while (NVM_STATUS & NVM_NVMBUSY_bp)
 315:xboot.c       ****                         {
 316:xboot.c       ****                                 // reset watchdog while waiting for erase completion
 317:xboot.c       ****                                 WDT_Reset();
 318:xboot.c       ****                         }
 319:xboot.c       ****                         #else // USE_WATCHDOG
 320:xboot.c       ****                         SP_WaitForSPM();
 321:xboot.c       ****                         #endif // USE_WATCHDOG
 322:xboot.c       ****                         
 323:xboot.c       ****                         // Randomize page buffer
 324:xboot.c       ****                         EEPROM_LoadPage(&val);
 325:xboot.c       ****                         // Erase EEPROM
 326:xboot.c       ****                         EEPROM_EraseAll();
 327:xboot.c       ****                         
 328:xboot.c       ****                         // acknowledge
 329:xboot.c       ****                         send_char(REPLY_ACK);
 330:xboot.c       ****                 }
 331:xboot.c       ****                 #ifdef ENABLE_BLOCK_SUPPORT
 332:xboot.c       ****                 // Check block load support
 333:xboot.c       ****                 else if (val == CMD_CHECK_BLOCK_SUPPORT )
 334:xboot.c       ****                 {
 335:xboot.c       ****                         // yes, it is supported
 336:xboot.c       ****                         send_char(REPLY_YES);
 337:xboot.c       ****                         // Send block size (page size)
 338:xboot.c       ****                         send_char((APP_SECTION_PAGE_SIZE >> 8) & 0xFF);
 339:xboot.c       ****                         send_char(APP_SECTION_PAGE_SIZE & 0xFF);
 340:xboot.c       ****                 }
 341:xboot.c       ****                 // Block load
 342:xboot.c       ****                 else if (val == CMD_BLOCK_LOAD)
 343:xboot.c       ****                 {
 344:xboot.c       ****                         // Block size
 345:xboot.c       ****                         i = get_2bytes();
 346:xboot.c       ****                         // Memory type
 347:xboot.c       ****                         val = get_char();
 348:xboot.c       ****                         // Load it
 349:xboot.c       ****                         send_char(BlockLoad(i, val, &address));
 350:xboot.c       ****                 }
 351:xboot.c       ****                 // Block read
 352:xboot.c       ****                 else if (val == CMD_BLOCK_READ)
 353:xboot.c       ****                 {
 354:xboot.c       ****                         // Block size
 355:xboot.c       ****                         i = get_2bytes();
 356:xboot.c       ****                         // Memory type
 357:xboot.c       ****                         val = get_char();
 358:xboot.c       ****                         // Read it
 359:xboot.c       ****                         BlockRead(i, val, &address);
 360:xboot.c       ****                 }
 361:xboot.c       ****                 #endif // ENABLE_BLOCK_SUPPORT
 362:xboot.c       ****                 #ifdef ENABLE_FLASH_BYTE_SUPPORT
 363:xboot.c       ****                 // Read program memory byte
 364:xboot.c       ****                 else if (val == CMD_READ_BYTE)
 365:xboot.c       ****                 {
 366:xboot.c       ****                         send_char(SP_ReadByte((address << 1)+1));
 367:xboot.c       ****                         send_char(SP_ReadByte((address << 1)+0));
 368:xboot.c       ****                         
 369:xboot.c       ****                         address++;
 370:xboot.c       ****                 }
 371:xboot.c       ****                 // Write program memory low byte
 372:xboot.c       ****                 else if (val == CMD_WRITE_LOW_BYTE)
 373:xboot.c       ****                 {
 374:xboot.c       ****                         // get low byte
 375:xboot.c       ****                         i = get_char();
 376:xboot.c       ****                         send_char(REPLY_ACK);
 377:xboot.c       ****                 }
 378:xboot.c       ****                 // Write program memory high byte
 379:xboot.c       ****                 else if (val == CMD_WRITE_HIGH_BYTE)
 380:xboot.c       ****                 {
 381:xboot.c       ****                         // get high byte; combine
 382:xboot.c       ****                         i |= (get_char() << 8);
 383:xboot.c       ****                         SP_LoadFlashWord((address << 1), i);
 384:xboot.c       ****                         address++;
 385:xboot.c       ****                         send_char(REPLY_ACK);
 386:xboot.c       ****                 }
 387:xboot.c       ****                 // Write page
 388:xboot.c       ****                 else if (val == CMD_WRITE_PAGE)
 389:xboot.c       ****                 {
 390:xboot.c       ****                         if (address >= (APP_SECTION_SIZE>>1))
 391:xboot.c       ****                         {
 392:xboot.c       ****                                 // don't allow bootloader overwrite
 393:xboot.c       ****                                 send_char(REPLY_ERROR);
 394:xboot.c       ****                         }
 395:xboot.c       ****                         else
 396:xboot.c       ****                         {
 397:xboot.c       ****                                 SP_WriteApplicationPage( address << 1);
 398:xboot.c       ****                                 send_char(REPLY_ACK);
 399:xboot.c       ****                         }
 400:xboot.c       ****                 }
 401:xboot.c       ****                 #endif // ENABLE_FLASH_BYTE_SUPPORT
 402:xboot.c       ****                 #ifdef ENABLE_EEPROM_BYTE_SUPPORT
 403:xboot.c       ****                 // Write EEPROM memory
 404:xboot.c       ****                 else if (val == CMD_WRITE_EEPROM_BYTE)
 405:xboot.c       ****                 {
 406:xboot.c       ****                         EEPROM_WriteByte( (unsigned char)(address / EEPROM_PAGE_SIZE), (unsigned ch
 407:xboot.c       ****                         address++;
 408:xboot.c       ****                 }
 409:xboot.c       ****                 // Read EEPROM memory
 410:xboot.c       ****                 else if (val == CMD_READ_EEPROM_BYTE)
 411:xboot.c       ****                 {
 412:xboot.c       ****                         send_char( EEPROM_ReadByte( (unsigned char)(address / EEPROM_PAGE_SIZE), (u
 413:xboot.c       ****                         address++;
 414:xboot.c       ****                 }
 415:xboot.c       ****                 #endif // ENABLE_EEPROM_BYTE_SUPPORT
 416:xboot.c       ****                 #ifdef ENABLE_LOCK_BITS
 417:xboot.c       ****                 // Write lockbits
 418:xboot.c       ****                 else if (val == CMD_WRITE_LOCK_BITS)
 419:xboot.c       ****                 {
 420:xboot.c       ****                         SP_WriteLockBits( get_char() );
 421:xboot.c       ****                         send_char(REPLY_ACK);
 422:xboot.c       ****                 }
 423:xboot.c       ****                 // Read lockbits
 424:xboot.c       ****                 else if (val == CMD_READ_LOCK_BITS)
 425:xboot.c       ****                 {
 426:xboot.c       ****                         send_char(SP_ReadLockBits());
 427:xboot.c       ****                 }
 428:xboot.c       ****                 #endif // ENABLE_LOCK_BITS
 429:xboot.c       ****                 #ifdef ENABLE_FUSE_BITS
 430:xboot.c       ****                 // Read low fuse bits
 431:xboot.c       ****                 else if (val == CMD_READ_LOW_FUSE_BITS)
 432:xboot.c       ****                 {
 433:xboot.c       ****                         send_char(SP_ReadFuseByte(0));
 434:xboot.c       ****                 }
 435:xboot.c       ****                 // Read high fuse bits
 436:xboot.c       ****                 else if (val == CMD_READ_HIGH_FUSE_BITS)
 437:xboot.c       ****                 {
 438:xboot.c       ****                         send_char(SP_ReadFuseByte(1));
 439:xboot.c       ****                 }
 440:xboot.c       ****                 // Read extended fuse bits
 441:xboot.c       ****                 else if (val == CMD_READ_EXT_FUSE_BITS)
 442:xboot.c       ****                 {
 443:xboot.c       ****                         send_char(SP_ReadFuseByte(2));
 444:xboot.c       ****                 }
 445:xboot.c       ****                 #endif // ENABLE_FUSE_BITS
 446:xboot.c       ****                 // Enter and leave programming mode
 447:xboot.c       ****                 else if ((val == CMD_ENTER_PROG_MODE) || (val == CMD_LEAVE_PROG_MODE))
 448:xboot.c       ****                 {
 449:xboot.c       ****                         // just acknowledge
 450:xboot.c       ****                         send_char(REPLY_ACK);
 451:xboot.c       ****                 }
 452:xboot.c       ****                 // Exit bootloader
 453:xboot.c       ****                 else if (val == CMD_EXIT_BOOTLOADER)
 454:xboot.c       ****                 {
 455:xboot.c       ****                         in_bootloader = 0;
 456:xboot.c       ****                         send_char(REPLY_ACK);
 457:xboot.c       ****                 }
 458:xboot.c       ****                 // Get programmer type
 459:xboot.c       ****                 else if (val == CMD_PROGRAMMER_TYPE)
 460:xboot.c       ****                 {
 461:xboot.c       ****                         // serial
 462:xboot.c       ****                         send_char('S');
 463:xboot.c       ****                 }
 464:xboot.c       ****                 // Return supported device codes
 465:xboot.c       ****                 else if (val == CMD_DEVICE_CODE)
 466:xboot.c       ****                 {
 467:xboot.c       ****                         // send only this device
 468:xboot.c       ****                         send_char(123); // TODO
 469:xboot.c       ****                         // terminator
 470:xboot.c       ****                         send_char(0);
 471:xboot.c       ****                 }
 472:xboot.c       ****                 // Set LED, clear LED, and set device type
 473:xboot.c       ****                 else if ((val == CMD_SET_LED) || (val == CMD_CLEAR_LED) || (val == CMD_SET_TYPE))
 474:xboot.c       ****                 {
 475:xboot.c       ****                         // discard parameter
 476:xboot.c       ****                         get_char();
 477:xboot.c       ****                         send_char(REPLY_ACK);
 478:xboot.c       ****                 }
 479:xboot.c       ****                 // Return program identifier
 480:xboot.c       ****                 else if (val == CMD_PROGRAM_ID)
 481:xboot.c       ****                 {
 482:xboot.c       ****                         send_char('X');
 483:xboot.c       ****                         send_char('B');
 484:xboot.c       ****                         send_char('o');
 485:xboot.c       ****                         send_char('o');
 486:xboot.c       ****                         send_char('t');
 487:xboot.c       ****                         send_char('+');
 488:xboot.c       ****                         send_char('+');
 489:xboot.c       ****                 }
 490:xboot.c       ****                 // Read software version
 491:xboot.c       ****                 else if (val == CMD_VERSION)
 492:xboot.c       ****                 {
 493:xboot.c       ****                         send_char('1');
 494:xboot.c       ****                         send_char('6');
 495:xboot.c       ****                 }
 496:xboot.c       ****                 // Read signature bytes
 497:xboot.c       ****                 else if (val == CMD_READ_SIGNATURE)
 498:xboot.c       ****                 {
 499:xboot.c       ****                         send_char(SIGNATURE_2);
 500:xboot.c       ****                         send_char(SIGNATURE_1);
 501:xboot.c       ****                         send_char(SIGNATURE_0);
 502:xboot.c       ****                 }
 503:xboot.c       ****                 #ifdef USE_I2C
 504:xboot.c       ****                 #ifdef USE_I2C_ADDRESS_NEGOTIATION
 505:xboot.c       ****                 // Enter autonegotiate mode
 506:xboot.c       ****                 else if (val == CMD_AUTONEG_START)
 507:xboot.c       ****                 {
 508:xboot.c       ****                         // The address autonegotiation protocol is borrowed from the
 509:xboot.c       ****                         // OneWire address detection method.  The algorthim Utilizes
 510:xboot.c       ****                         // one extra shared wire, pulled up by resistors just like the
 511:xboot.c       ****                         // main I2C bus, a OneWire bus, or a wired-AND IRQ line.
 512:xboot.c       ****                         // The protocol involves intelligently guessing all of the
 513:xboot.c       ****                         // connected devices' 88 bit unique hardware ID numbers, stored
 514:xboot.c       ****                         // permanently in the production signature row during manufacture
 515:xboot.c       ****                         // (see XMega series datasheet for details)
 516:xboot.c       ****                         #ifdef __AVR_XMEGA__
 517:xboot.c       ****                         // k is temp
 518:xboot.c       ****                         // devid is pointer to current bit, init to first bit
 519:xboot.c       ****                         // of the hardware ID in the production signature row
 520:xboot.c       ****                         devid_bit = 0x08 << 3;
 521:xboot.c       ****                         // read first byte of hardware ID into temporary location
 522:xboot.c       ****                         k = SP_ReadCalibrationByte(0x08);
 523:xboot.c       ****                         
 524:xboot.c       ****                         // main negotiation loop
 525:xboot.c       ****                         while (1)
 526:xboot.c       ****                         {
 527:xboot.c       ****                                 // wait for incoming data
 528:xboot.c       ****                                 while (1)
 529:xboot.c       ****                                 {
 530:xboot.c       ****                                         // check for bit read command
 531:xboot.c       ****                                         if (!(I2C_AUTONEG_PORT.IN & (1 << I2C_AUTONEG_PIN)))
 532:xboot.c       ****                                         {
 533:xboot.c       ****                                                 // write current bit of hardware ID
 534:xboot.c       ****                                                 ow_slave_write_bit(k & 1);  // write bit
 535:xboot.c       ****                                                 break;
 536:xboot.c       ****                                         }
 537:xboot.c       ****                                         // check for I2C bus activity
 538:xboot.c       ****                                         else if (I2C_DEVICE.SLAVE.STATUS & (TWI_SLAVE_APIF_bm | TWI
 539:xboot.c       ****                                         {
 540:xboot.c       ****                                                 // grab a byte
 541:xboot.c       ****                                                 // (there will be no I2C bus activity while
 542:xboot.c       ****                                                 // the autonegotiation is taking place,
 543:xboot.c       ****                                                 // so it's OK to block)
 544:xboot.c       ****                                                 val = get_char();
 545:xboot.c       ****                                                 // Is this an address byte for me?
 546:xboot.c       ****                                                 if (val == CMD_AUTONEG_DONE)
 547:xboot.c       ****                                                 {
 548:xboot.c       ****                                                         // If so, we're now attached, so light
 549:xboot.c       ****                                                         // the LED and update the I2C bus
 550:xboot.c       ****                                                         // controller accordingly
 551:xboot.c       ****                                                         
 552:xboot.c       ****                                                         // turn on attach LED
 553:xboot.c       ****                                                         #ifdef USE_ATTACH_LED
 554:xboot.c       ****                                                         #if ATTACH_LED_INV
 555:xboot.c       ****                                                         ATTACH_LED_PORT.OUTCLR = (1 << ATTACH_LED_P
 556:xboot.c       ****                                                         #else
 557:xboot.c       ****                                                         ATTACH_LED_PORT.OUTSET = (1 << ATTACH_LED_P
 558:xboot.c       ****                                                         #endif // ATTACH_LED_INV
 559:xboot.c       ****                                                         #endif // USE_ATTACH_LED
 560:xboot.c       ****                                                         
 561:xboot.c       ****                                                         // get new address
 562:xboot.c       ****                                                         #if I2C_AUTONEG_DIS_GC
 563:xboot.c       ****                                                         I2C_DEVICE.SLAVE.ADDR = get_char() << 1;
 564:xboot.c       ****                                                         #else
 565:xboot.c       ****                                                         I2C_DEVICE.SLAVE.ADDR = (get_char() << 1) |
 566:xboot.c       ****                                                         #endif // I2C_AUTONEG_DIS_GC
 567:xboot.c       ****                                                         
 568:xboot.c       ****                                                         #if I2C_AUTONEG_DIS_PROMISC
 569:xboot.c       ****                                                         // turn off promiscuous mode
 570:xboot.c       ****                                                         I2C_DEVICE.SLAVE.CTRLA = TWI_SLAVE_ENABLE_b
 571:xboot.c       ****                                                         #endif // I2C_AUTONEG_DIS_PROMISC
 572:xboot.c       ****                                                         
 573:xboot.c       ****                                                         // we're done here
 574:xboot.c       ****                                                         goto autoneg_done;
 575:xboot.c       ****                                                 }
 576:xboot.c       ****                                                 // Check for sync command
 577:xboot.c       ****                                                 else if (val == CMD_SYNC)
 578:xboot.c       ****                                                 {
 579:xboot.c       ****                                                         // break out to main bootloader on sync
 580:xboot.c       ****                                                         goto autoneg_done;
 581:xboot.c       ****                                                 }
 582:xboot.c       ****                                         }
 583:xboot.c       ****                                 }
 584:xboot.c       ****                                 // Already wrote normal bit, so write the inverted one
 585:xboot.c       ****                                 ow_slave_write_bit(~k & 1); // write inverted bit
 586:xboot.c       ****                                 // Now read master's guess
 587:xboot.c       ****                                 i = ow_slave_read_bit();
 588:xboot.c       ****                                 // Does the guess agree with the current bit?
 589:xboot.c       ****                                 if ((k & 1 && i) || (~k & 1 && !i))
 590:xboot.c       ****                                 {
 591:xboot.c       ****                                         // look at next bit
 592:xboot.c       ****                                         devid_bit++;
 593:xboot.c       ****                                         k >>= 1;
 594:xboot.c       ****                                         
 595:xboot.c       ****                                         // time for next byte?
 596:xboot.c       ****                                         if (!(devid_bit & 7))
 597:xboot.c       ****                                         {
 598:xboot.c       ****                                                 // Out of bits?
 599:xboot.c       ****                                                 if (devid_bit > (0x15 << 3))
 600:xboot.c       ****                                                 {
 601:xboot.c       ****                                                         // Can't break here (need to wait
 602:xboot.c       ****                                                         // to see if the master sends along
 603:xboot.c       ****                                                         // an address) so wrap around instead
 604:xboot.c       ****                                                         devid_bit = 0x08 << 3;
 605:xboot.c       ****                                                 }
 606:xboot.c       ****                                                 // there are some holes in the signature row,
 607:xboot.c       ****                                                 // so skip over them
 608:xboot.c       ****                                                 if (devid_bit == (0x0E << 3))
 609:xboot.c       ****                                                         devid_bit += 0x02 << 3;
 610:xboot.c       ****                                                 if (devid_bit == (0x11 << 3))
 611:xboot.c       ****                                                         devid_bit += 0x01 << 3;
 612:xboot.c       ****                                                 // Read next byte
 613:xboot.c       ****                                                 k = SP_ReadCalibrationByte(k >> 3);
 614:xboot.c       ****                                         }
 615:xboot.c       ****                                 }
 616:xboot.c       ****                                 else
 617:xboot.c       ****                                 {
 618:xboot.c       ****                                         // No match, we're done here
 619:xboot.c       ****                                         break;
 620:xboot.c       ****                                 }
 621:xboot.c       ****                         }
 622:xboot.c       ****                         
 623:xboot.c       **** autoneg_done:
 624:xboot.c       ****                         // dummy to avoid error message
 625:xboot.c       ****                         // this actually produces code 4 bytes smaller than either
 626:xboot.c       ****                         // an asm nop, a continue, or a bare semicolon
 627:xboot.c       ****                         i = 0;
 628:xboot.c       ****                         
 629:xboot.c       ****                         #endif // __AVR_XMEGA__
 630:xboot.c       ****                 }
 631:xboot.c       ****                 // out-of-order autonegotiate address message
 632:xboot.c       ****                 else if (val == CMD_AUTONEG_DONE)
 633:xboot.c       ****                 {
 634:xboot.c       ****                         // ignore it
 635:xboot.c       ****                         // (blocking to send a ? will cause trouble)
 636:xboot.c       ****                 }
 637:xboot.c       ****                 #endif // USE_I2C_ADDRESS_NEGOTIATION
 638:xboot.c       ****                 #endif // USE_I2C
 639:xboot.c       ****                 // ESC (0x1b) to sync
 640:xboot.c       ****                 // otherwise, error
 641:xboot.c       ****                 else if (val != CMD_SYNC)
 642:xboot.c       ****                 {
 643:xboot.c       ****                         send_char(REPLY_ERROR);
 644:xboot.c       ****                 }
 645:xboot.c       ****                 
 646:xboot.c       ****                 // Wait for any lingering SPM instructions to finish
 647:xboot.c       ****                 SP_WaitForSPM();
 648:xboot.c       ****                 
 649:xboot.c       ****                 // End of bootloader main loop
 650:xboot.c       ****         }
 651:xboot.c       ****         
 652:xboot.c       ****         #ifdef NEED_INTERRUPTS
 653:xboot.c       ****         // Disable interrupts
 654:xboot.c       ****         cli();
 655:xboot.c       ****         #endif // NEED_INTERRUPTS
 656:xboot.c       ****         
 657:xboot.c       ****         // Bootloader exit section
 658:xboot.c       ****         // Code here runs after the bootloader has exited,
 659:xboot.c       ****         // but before the application code has started
 660:xboot.c       ****         // --------------------------------------------------
 661:xboot.c       ****         
 662:xboot.c       ****         #ifdef USE_FIFO
 663:xboot.c       ****         // Shut down FIFO
 664:xboot.c       ****         fifo_deinit();
 665:xboot.c       ****         #endif // USE_FIFO
 666:xboot.c       ****         
 667:xboot.c       ****         #ifdef USE_I2C
 668:xboot.c       ****         // Shut down I2C interface
 669:xboot.c       ****         i2c_deinit();
 670:xboot.c       ****         #endif // USE_I2C
 671:xboot.c       ****         
 672:xboot.c       ****         #ifdef USE_UART
 673:xboot.c       ****         // Shut down UART
 674:xboot.c       ****         uart_deinit();
 675:xboot.c       ****         #endif // USE_UART
 676:xboot.c       ****         
 677:xboot.c       ****         #ifdef LOCK_SPM_ON_EXIT
 678:xboot.c       ****         // Lock SPM writes
 679:xboot.c       ****         SP_LockSPM();
 680:xboot.c       ****         #endif // LOCK_SPM_ON_EXIT
 681:xboot.c       ****         
 682:xboot.c       ****         #ifdef USE_LED
 683:xboot.c       ****         // Turn off LED on exit
 684:xboot.c       ****         LED_PORT.DIRCLR = (1 << LED_PIN);
 685:xboot.c       ****         #endif // USE_LED
 686:xboot.c       ****         
 687:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 688:xboot.c       ****         #ifdef USE_ATTACH_LED
 689:xboot.c       ****         // Disable ATTACH_LED
 690:xboot.c       ****         ATTACH_LED_PORT.DIRSET = (1 << ATTACH_LED_PIN);
 691:xboot.c       ****         #endif // USE_ATTACH_LED
 692:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 693:xboot.c       ****         
 694:xboot.c       ****         #ifdef NEED_INTERRUPTS
 695:xboot.c       ****         // remap interrupts back to application section
 696:xboot.c       ****         CCP = CCP_IOREG_gc;
 697:xboot.c       ****         PMIC.CTRL = 0;
 698:xboot.c       ****         #endif // NEED_INTERRUPTS
 699:xboot.c       **** 
 700:xboot.c       ****         #ifdef USE_WATCHDOG
 701:xboot.c       ****         WDT_Disable();
 702:xboot.c       ****         #endif // USE_WATCHDOG
 703:xboot.c       ****         
 704:xboot.c       ****         // --------------------------------------------------
 705:xboot.c       ****         // End bootloader exit section
 706:xboot.c       ****         
 707:xboot.c       ****         // Jump into main code
 708:xboot.c       ****         EIND = 0x00;
 709:xboot.c       ****         reset_vect();
 710:xboot.c       **** }
 711:xboot.c       **** 
 712:xboot.c       **** #ifdef USE_I2C_ADDRESS_NEGOTIATION
 713:xboot.c       **** 
 714:xboot.c       **** #ifdef __AVR_XMEGA__
 715:xboot.c       **** #define ow_assert()             I2C_AUTONEG_PORT.DIRSET = (1 << I2C_AUTONEG_PIN)
 716:xboot.c       **** #define ow_deassert()           I2C_AUTONEG_PORT.DIRCLR = (1 << I2C_AUTONEG_PIN)
 717:xboot.c       **** #define ow_read()               (I2C_AUTONEG_PORT.IN & (1 << I2C_AUTONEG_PIN))
 718:xboot.c       **** #define ow_is_asserted()        (!ow_read())
 719:xboot.c       **** #else
 720:xboot.c       **** #define ow_assert()             DDRC |= (1 << 0)
 721:xboot.c       **** #define ow_deassert()           DDRC &= ~(1 << 0)
 722:xboot.c       **** #define ow_read()               (PINC & (1 << 0))
 723:xboot.c       **** #define ow_is_asserted()        (!ow_read())
 724:xboot.c       **** #endif // __AVR_XMEGA__
 725:xboot.c       **** 
 726:xboot.c       **** unsigned char __attribute__ ((noinline)) ow_slave_read_bit(void)
 727:xboot.c       **** {
 728:xboot.c       ****         unsigned char ret;
 729:xboot.c       ****         ow_slave_wait_bit();
 730:xboot.c       ****         _delay_us(12);
 731:xboot.c       ****         ret = ow_read();
 732:xboot.c       ****         _delay_us(8);
 733:xboot.c       ****         return ret;
 734:xboot.c       **** }
 735:xboot.c       **** 
 736:xboot.c       **** void __attribute__ ((noinline)) ow_slave_write_bit(unsigned char b)
 737:xboot.c       **** {
 738:xboot.c       ****         ow_slave_wait_bit();
 739:xboot.c       ****         if (!b)
 740:xboot.c       ****         {
 741:xboot.c       ****                 ow_assert();
 742:xboot.c       ****         }
 743:xboot.c       ****         _delay_us(20);
 744:xboot.c       ****         ow_deassert();
 745:xboot.c       **** }
 746:xboot.c       **** 
 747:xboot.c       **** void ow_slave_wait_bit(void)
 748:xboot.c       **** {
 749:xboot.c       ****         while (ow_read()) { };
 750:xboot.c       **** }
 751:xboot.c       **** 
 752:xboot.c       **** #endif // USE_I2C_ADDRESS_NEGOTIATION
 753:xboot.c       **** 
 754:xboot.c       **** #ifdef USE_INTERRUPTS
 755:xboot.c       **** unsigned char __attribute__ ((noinline)) get_char(void)
 756:xboot.c       **** {
 757:xboot.c       ****         unsigned char ret;
 758:xboot.c       ****         
 759:xboot.c       ****         while (rx_char_cnt == 0) { };
 760:xboot.c       ****         
 761:xboot.c       ****         cli();
 762:xboot.c       ****         
 763:xboot.c       ****         ret = rx_buff0;
 764:xboot.c       ****         rx_buff0 = rx_buff1;
 765:xboot.c       ****         rx_char_cnt--;
 766:xboot.c       ****         
 767:xboot.c       ****         sei();
 768:xboot.c       ****         
 769:xboot.c       ****         return ret;
 770:xboot.c       **** }
 771:xboot.c       **** 
 772:xboot.c       **** void __attribute__ ((noinline)) send_char(unsigned char c)
 773:xboot.c       **** {
 774:xboot.c       ****         while (1)
 775:xboot.c       ****         {
 776:xboot.c       ****                 cli();
 777:xboot.c       ****                 
 778:xboot.c       ****                 if (tx_char_cnt == 0)
 779:xboot.c       ****                 {
 780:xboot.c       ****                         tx_buff0 = c;
 781:xboot.c       ****                         tx_char_cnt = 1;
 782:xboot.c       ****                         #ifdef USE_UART
 783:xboot.c       ****                         if (comm_mode == MODE_UART)
 784:xboot.c       ****                         {
 785:xboot.c       ****                                 uart_send_char(c);
 786:xboot.c       ****                         }
 787:xboot.c       ****                         #endif // USE_UART
 788:xboot.c       ****                         #ifdef USE_FIFO
 789:xboot.c       ****                         if (comm_mode == MODE_FIFO)
 790:xboot.c       ****                         {
 791:xboot.c       ****                                 fifo_send_char(c);
 792:xboot.c       ****                         }
 793:xboot.c       ****                         #endif // USE_FIFO
 794:xboot.c       ****                         sei();
 795:xboot.c       ****                         return;
 796:xboot.c       ****                 }
 797:xboot.c       ****                 
 798:xboot.c       ****                 sei();
 799:xboot.c       ****         }
 800:xboot.c       **** }
 801:xboot.c       **** 
 802:xboot.c       **** #else
 803:xboot.c       **** 
 804:xboot.c       **** unsigned char __attribute__ ((noinline)) get_char(void)
 805:xboot.c       **** {
 398               	n	68,0,805,.LM0-.LFBB1
 399               	.LM0:
 400               	.LFBB1:
 401               	/* prologue: function */
 402               	/* frame size = 0 */
 806:xboot.c       ****    if (comm_mode == MODE_UNDEF || comm_mode == MODE_UART)
 807:xboot.c       ****                 {
 808:xboot.c       ****                         #ifdef __AVR_XMEGA__
 809:xboot.c       ****                         if (uart_char_received())
 810:xboot.c       ****                         {
 811:xboot.c       ****                                 comm_mode = MODE_UART;
 812:xboot.c       ****                                 return uart_cur_char();
 403               	bn	68,0,812,.LM1-.LFBB1
 404               	.LM1:
 405 0000 9091 0000 		lds r25,comm_mode
 406               	.L3:
 407 0004 9230      		cpi r25,lo8(2)
 408 0006 00F4      		brsh .L2
 813:xboot.c       ****                  }
 814:xboot.c       ****                         #endif // __AVR_XMEGA__
 815:xboot.c       ****                 }
 409               	n	68,0,815,.LM2-.LFBB1
 410               	.LM2:
 411 0008 8091 B109 		lds r24,2481
 412 000c 87FF      		sbrs r24,7
 413 000e 00C0      		rjmp .L3
 816:xboot.c       ****              #endif // USE_UART
 817:xboot.c       ****                 
 414               	bn	68,0,817,.LM3-.LFBB1
 415               	.LM3:
 416 0010 81E0      		ldi r24,lo8(1)
 417 0012 8093 0000 		sts comm_mode,r24
 818:xboot.c       ****               #ifdef USE_I2C
 418               	abn	68,0,818,.LM4-.LFBB1
 419               	.LM4:
 420 0016 8091 B009 		lds r24,2480
 421               	/* epilogue start */
 819:xboot.c       ****                // Get next character
 820:xboot.c       ****                 if (comm_mode == MODE_UNDEF || comm_mode == MODE_I2C)
 821:xboot.c       ****                 {
 822:xboot.c       ****                         #ifdef __AVR_XMEGA__
 823:xboot.c       ****                         if (i2c_address_match())
 824:xboot.c       ****                         {
 825:xboot.c       ****                                 // Address match, send ACK
 826:xboot.c       ****                                 i2c_send_ack();
 827:xboot.c       ****                                 comm_mode = MODE_I2C;
 828:xboot.c       ****                                 first_byte = 1;
 829:xboot.c       ****                         }
 830:xboot.c       ****                         if (i2c_char_received())
 831:xboot.c       ****                         {
 832:xboot.c       ****                                 // Data has arrived
 833:xboot.c       ****                                 ret = i2c_cur_char();
 834:xboot.c       ****                                 i2c_send_ack();
 835:xboot.c       ****                                 return ret;
 836:xboot.c       ****                         }
 837:xboot.c       ****                         if (i2c_ready_data())
 838:xboot.c       ****                         {
 839:xboot.c       ****                                 if (!first_byte && i2c_got_ack())
 840:xboot.c       ****                                 {
 841:xboot.c       ****                                         i2c_end_transmission(); // end transaction
 842:xboot.c       ****                                 }
 843:xboot.c       ****                                 else
 844:xboot.c       ****                                 {
 845:xboot.c       ****                                         first_byte = 0;
 846:xboot.c       ****                                         // Wants data, but there is no data to send...
 847:xboot.c       ****                                         // also include NAK
 848:xboot.c       ****                                         i2c_send_char(REPLY_ERROR);
 849:xboot.c       ****                                         i2c_send_nak();
 850:xboot.c       ****                                 }
 851:xboot.c       ****                         }
 852:xboot.c       ****                         #endif // __AVR_XMEGA__
 853:xboot.c       ****                 }
 854:xboot.c       ****                 #endif // USE_I2C
 855:xboot.c       **** 
 856:xboot.c       ****                 #ifdef USE_FIFO
 857:xboot.c       ****                 // Get next character
 858:xboot.c       ****                 if (comm_mode == MODE_UNDEF || comm_mode == MODE_FIFO)
 859:xboot.c       ****                 {
 860:xboot.c       ****                         #ifdef __AVR_XMEGA__
 861:xboot.c       ****                         if (fifo_char_received())
 862:xboot.c       ****                         {
 863:xboot.c       ****                                 comm_mode = MODE_FIFO;
 864:xboot.c       ****                                 return fifo_cur_char();
 865:xboot.c       ****                         }
 866:xboot.c       ****                         #endif // __AVR_XMEGA__
 867:xboot.c       ****                 }
 868:xboot.c       ****                 #endif // USE_FIFO
 869:xboot.c       ****                 
 870:xboot.c       ****         }
 871:xboot.c       ****         
 872:xboot.c       ****         return ret;
 873:xboot.c       **** }
 874:xboot.c       **** 
 875:xboot.c       **** void __attribute__ ((noinline)) send_char(unsigned char c)
 876:xboot.c       **** {
 877:xboot.c       ****         #ifdef USE_I2C
 878:xboot.c       ****         unsigned char tmp;
 879:xboot.c       ****         #endif
 422               	abn	68,0,879,.LM5-.LFBB1
 423               	.LM5:
 424 001a 0895      		ret
 425               	.L2:
 426               	.L6:
 427 001c 00C0      		rjmp .L6
 429               	.Lscope1:
 432               	.global	send_char
 434               	send_char:
 880:xboot.c       ****       if (comm_mode == MODE_UNDEF || comm_mode == MODE_UART)
 881:xboot.c       ****         {
 882:xboot.c       ****                 #ifdef __AVR_XMEGA__
 435               	882,.LM6-.LFBB2
 436               	.LM6:
 437               	.LFBB2:
 438               	/* prologue: function */
 439               	/* frame size = 0 */
 440 001e 982F      		mov r25,r24
 883:xboot.c       ****              uart_send_char_blocking(c);
 884:xboot.c       ****                 #endif // __AVR_XMEGA__
 885:xboot.c       ****                 
 886:xboot.c       ****         }
 887:xboot.c       ****         #endif // USE_UART
 888:xboot.c       ****         
 889:xboot.c       ****         #ifdef USE_I2C
 441               	n	68,0,889,.LM7-.LFBB2
 442               	.LM7:
 443 0020 8091 0000 		lds r24,comm_mode
 444 0024 8230      		cpi r24,lo8(2)
 445 0026 00F4      		brsh .L10
 890:xboot.c       ****  // Send character
 891:xboot.c       ****         if (comm_mode == MODE_UNDEF || comm_mode == MODE_I2C)
 892:xboot.c       ****         {
 446               	bn	68,0,892,.LM8-.LFBB2
 447               	.LM8:
 448 0028 9093 B009 		sts 2480,r25
 449               	.L9:
 450 002c 8091 B109 		lds r24,2481
 451 0030 86FF      		sbrs r24,6
 452 0032 00C0      		rjmp .L9
 453 0034 8091 B109 		lds r24,2481
 454 0038 8064      		ori r24,lo8(64)
 455 003a E0EB      		ldi r30,lo8(2480)
 456 003c F9E0      		ldi r31,hi8(2480)
 457 003e 8183      		std Z+1,r24
 458               	.L10:
 459 0040 0895      		ret
 461               	.Lscope2:
 463               	.global	get_2bytes
 465               	get_2bytes:
 893:xboot.c       ****              while (1)
 894:xboot.c       ****                 {
 895:xboot.c       ****                         #ifdef __AVR_XMEGA__
 896:xboot.c       ****                         if (i2c_address_match())
 897:xboot.c       ****                         {
 898:xboot.c       ****                                 // Address match, send ACK
 899:xboot.c       ****                                 i2c_send_ack();
 900:xboot.c       ****                                 first_byte = 1;
 901:xboot.c       ****                         }
 902:xboot.c       ****                         if (i2c_char_received())
 903:xboot.c       ****                         {
 904:xboot.c       ****                                 // Data has arrived, ignore it
 905:xboot.c       ****                                 tmp = i2c_cur_char();
 906:xboot.c       ****                                 i2c_send_ack();
 907:xboot.c       ****                         }
 908:xboot.c       ****                         if (i2c_ready_data())
 909:xboot.c       ****                         {
 910:xboot.c       ****                                 if (!first_byte && i2c_got_ack())
 911:xboot.c       ****                                 {
 912:xboot.c       ****                                         i2c_end_transmission(); // end transaction
 913:xboot.c       ****                                 }
 914:xboot.c       ****                                 else
 915:xboot.c       ****                                 {
 916:xboot.c       ****                                         first_byte = 0;
 917:xboot.c       ****                                         // Send data along
 918:xboot.c       ****                                         i2c_send_char(c);
 919:xboot.c       ****                                         i2c_send_ack();
 920:xboot.c       ****                                 }
 921:xboot.c       ****                                 return;
 922:xboot.c       ****                         }
 923:xboot.c       ****                         #endif // __AVR_XMEGA__
 924:xboot.c       ****                 }
 925:xboot.c       ****         }
 926:xboot.c       ****         #endif // USE_I2C
 927:xboot.c       **** 
 928:xboot.c       ****         #ifdef USE_FIFO
 929:xboot.c       ****         // Send character
 930:xboot.c       ****         if (comm_mode == MODE_UNDEF || comm_mode == MODE_FIFO)
 931:xboot.c       ****         {
 932:xboot.c       ****                 #ifdef __AVR_XMEGA__
 933:xboot.c       ****                 fifo_send_char_blocking(c);
 934:xboot.c       ****                 #endif // __AVR_XMEGA__
 935:xboot.c       ****                 
 936:xboot.c       ****         }
 937:xboot.c       ****         #endif // USE_FIFO
 938:xboot.c       ****         
 939:xboot.c       **** }
 940:xboot.c       **** 
 941:xboot.c       **** #endif // USE_INTERRUPTS
 942:xboot.c       **** 
 943:xboot.c       **** unsigned int __attribute__ ((noinline)) get_2bytes()
 944:xboot.c       **** {
 945:xboot.c       ****         // return (get_char() << 8) | get_char();
 946:xboot.c       ****         unsigned int result;
 947:xboot.c       ****         asm volatile (
 948:xboot.c       ****                 "call get_char"    "\n\t"
 949:xboot.c       ****                 "mov  %B0,r24"     "\n\t"
 950:xboot.c       ****                 "call get_char"    "\n\t"
 951:xboot.c       ****                 "mov  %A0,r24"     "\n\t"
 952:xboot.c       ****                 : "=r" (result)
 953:xboot.c       ****                 :
 466               	9-.LFBB3
 467               	.LM9:
 468               	.LFBB3:
 469               	/* prologue: function */
 470               	/* frame size = 0 */
 954:xboot.c       **** unsigned int size, unsigned char mem, ADDR_T *address)
 955:xboot.c       **** {
 956:xboot.c       ****         unsigned int data;
 471               	bn	68,0,956,.LM10-.LFBB3
 472               	.LM10:
 473               	/* #APP */
 474               	 ;  956 "xboot.c" 1
 475 0042 0E94 0000 		call get_char
 476 0046 382F      		mov  r19,r24
 477 0048 0E94 0000 		call get_char
 478 004c 282F      		mov  r18,r24
 479               		
 480               	 ;  0 "" 2
 957:xboot.c       ****      ADDR_T tempaddress;
 958:xboot.c       ****         
 959:xboot.c       **** 	#ifdef USE_WATCHDOG
 960:xboot.c       **** 	WDT_Reset();
 961:xboot.c       **** 	#endif // USE_WATCHDOG
 962:xboot.c       **** 
 963:xboot.c       ****         // EEPROM memory type.
 964:xboot.c       ****         if(mem == MEM_EEPROM)
 965:xboot.c       ****         {
 481               	,0,965,.LM11-.LFBB3
 482               	.LM11:
 483               	/* #NOAPP */
 484 004e C901      		movw r24,r18
 485               	/* epilogue start */
 486 0050 0895      		ret
 491               	.Lscope3:
 496               	.global	BlockRead
 498               	BlockRead:
 966:xboot.c       ****        unsigned char pageAddr, byteAddr, value;
 967:xboot.c       ****                 unsigned char buffer[APP_SECTION_PAGE_SIZE];
 968:xboot.c       ****                 
 969:xboot.c       ****                 EEPROM_FlushBuffer();
 970:xboot.c       ****                 // disable mapping of EEPROM into data space (enable IO mapped access)
 971:xboot.c       ****                 EEPROM_DisableMapping();
 972:xboot.c       ****                 
 973:xboot.c       ****                 // Fill buffer first, as EEPROM is too slow to copy with UART speed 
 974:xboot.c       ****                 for(tempaddress=0;tempaddress<size;tempaddress++){
 975:xboot.c       ****                         buffer[tempaddress] = get_char();
 976:xboot.c       ****                 }
 977:xboot.c       ****                 
 978:xboot.c       ****                 // Then program the EEPROM
 979:xboot.c       ****                 for( tempaddress=0; tempaddress < size; tempaddress++)
 980:xboot.c       ****                 {
 981:xboot.c       ****                         // void EEPROM_WriteByte( uint8_t pageAddr, uint8_t byteAddr, uint8_t value
 982:xboot.c       ****                         pageAddr = (unsigned char)( (*address) / EEPROM_PAGE_SIZE);
 983:xboot.c       ****                         byteAddr = (unsigned char)( (*address) & EEPROM_BYTE_ADDRESS_MASK);
 984:xboot.c       ****                         value = buffer[tempaddress];
 985:xboot.c       ****                         
 986:xboot.c       ****                         EEPROM_WriteByte(pageAddr, byteAddr, value);
 987:xboot.c       ****                         
 988:xboot.c       ****                         (*address)++; // Select next EEPROM byte
 989:xboot.c       ****                 }
 990:xboot.c       ****                 
 991:xboot.c       ****                 return REPLY_ACK; // Report programming OK
 992:xboot.c       ****         } 
 993:xboot.c       ****         
 994:xboot.c       ****         // Flash memory type
 995:xboot.c       ****         else if (mem == MEM_FLASH || mem == MEM_USERSIG)
 996:xboot.c       ****         {
 997:xboot.c       ****                 // NOTE: For flash programming, 'address' is given in words.
 998:xboot.c       ****                 (*address) <<= 1; // Convert address to bytes temporarily.
 999:xboot.c       ****                 tempaddress = (*address);  // Store address in page.
1000:xboot.c       ****                 
1001:xboot.c       ****                 do
1002:xboot.c       ****                 {
1003:xboot.c       ****                         data = get_char();
1004:xboot.c       ****                         data |= (get_char() << 8);
1005:xboot.c       ****                         SP_LoadFlashWord(*address, data);
1006:xboot.c       ****                         (*address)+=2; // Select next word in memory.
1007:xboot.c       ****                         size -= 2; // Reduce number of bytes to write by two.
1008:xboot.c       ****                 } while(size); // Loop until all bytes written.
1009:xboot.c       ****                 
1010:xboot.c       ****                 if (mem == MEM_FLASH)
1011:xboot.c       ****                 {
1012:xboot.c       ****                         SP_WriteApplicationPage(tempaddress);
1013:xboot.c       ****                 }
1014:xboot.c       ****                 else if (mem == MEM_USERSIG)
1015:xboot.c       ****                 {
1016:xboot.c       ****                         SP_EraseUserSignatureRow();
1017:xboot.c       ****                         SP_WaitForSPM();
1018:xboot.c       ****                         SP_WriteUserSignatureRow();
1019:xboot.c       ****                 }
1020:xboot.c       ****                 
1021:xboot.c       ****                 SP_WaitForSPM();
1022:xboot.c       ****                 
1023:xboot.c       ****                 (*address) >>= 1; // Convert address back to Flash words again.
1024:xboot.c       ****                 return REPLY_ACK; // Report programming OK
1025:xboot.c       ****         }
1026:xboot.c       **** 
1027:xboot.c       ****         // Invalid memory type?
1028:xboot.c       ****         else
1029:xboot.c       ****         {
1030:xboot.c       ****                 return REPLY_ERROR;
1031:xboot.c       ****         }
1032:xboot.c       **** }
1033:xboot.c       **** 
1034:xboot.c       **** 
1035:xboot.c       **** 
1036:xboot.c       **** void BlockRead(unsigned int size, unsigned char mem, ADDR_T *address)
1037:xboot.c       **** {
1038:xboot.c       ****         // EEPROM memory type.
1039:xboot.c       ****         
1040:xboot.c       ****         if (mem == MEM_EEPROM) // Read EEPROM
1041:xboot.c       ****         {
1042:xboot.c       ****                 unsigned char byteAddr, pageAddr;
1043:xboot.c       ****                 
1044:xboot.c       ****                 EEPROM_DisableMapping();
1045:xboot.c       ****                 EEPROM_FlushBuffer();
1046:xboot.c       ****                 
1047:xboot.c       ****                 do
1048:xboot.c       ****                 {
1049:xboot.c       ****                         pageAddr = (unsigned char)(*address / EEPROM_PAGE_SIZE);
1050:xboot.c       ****                         byteAddr = (unsigned char)(*address & EEPROM_BYTE_ADDRESS_MASK);
 499               	.LM12-.LFBB4
 500               	.LM12:
 501               	.LFBB4:
 502 0052 EF92      		push r14
 503 0054 FF92      		push r15
 504 0056 1F93      		push r17
 505 0058 CF93      		push r28
 506 005a DF93      		push r29
 507               	/* prologue: function */
 508               	/* frame size = 0 */
 509 005c 7C01      		movw r14,r24
 510 005e 162F      		mov r17,r22
 511 0060 EA01      		movw r28,r20
1051:xboot.c       **** , byteAddr ) );
1052:xboot.c       ****                         // Select next EEPROM byte
1053:xboot.c       ****                         (*address)++;
 512               	1053,.LM13-.LFBB4
 513               	.LM13:
 514 0062 6534      		cpi r22,lo8(69)
 515 0064 01F4      		brne .L15
 516               	.LBB2:
1054:xboot.c       ****                         (*address)++;
1055:xboot.c       ****                         size--; // Decrease number of bytes to read
1056:xboot.c       ****                 } while (size); // Repeat until all block has been read
1057:xboot.c       ****         }
 517               	bn	68,0,1057,.LM14-.LFBB4
 518               	.LM14:
 519 0066 8091 CC01 		lds r24,460
 520 006a 877F      		andi r24,lo8(-9)
 521 006c E0EC      		ldi r30,lo8(448)
 522 006e F1E0      		ldi r31,hi8(448)
 523 0070 8487      		std Z+12,r24
1058:xboot.c       ****  all block has been read
 524               		68,0,1058,.LM15-.LFBB4
 525               	.LM15:
 526 0072 0E94 0000 		call EEPROM_FlushBuffer
 527               	.L16:
1059:xboot.c       **** epeat until all block has been read
1060:xboot.c       ****         }
1061:xboot.c       ****         
1062:xboot.c       ****         // Flash memory type.
 528               	abn	68,0,1062,.LM16-.LFBB4
 529               	.LM16:
 530 0076 8881      		ld r24,Y
 531 0078 9981      		ldd r25,Y+1
 532 007a AA81      		ldd r26,Y+2
 533 007c BB81      		ldd r27,Y+3
1063:xboot.c       ****   
1064:xboot.c       ****         // Flash memory type.
1065:xboot.c       ****         else if (mem == MEM_FLASH || mem == MEM_USERSIG || mem == MEM_PRODSIG)
 534               	n	68,0,1065,.LM17-.LFBB4
 535               	.LM17:
 536 007e 682F      		mov r22,r24
 537 0080 6F71      		andi r22,lo8(31)
 538 0082 45E0      		ldi r20,5
 539 0084 B695      	1:	lsr r27
 540 0086 A795      		ror r26
 541 0088 9795      		ror r25
 542 008a 8795      		ror r24
 543 008c 4A95      		dec r20
 544 008e 01F4      		brne 1b
 545 0090 0E94 0000 		call EEPROM_ReadByte
 546 0094 0E94 0000 		call send_char
1066:xboot.c       **** _USERSIG || mem == MEM_PRODSIG)
1067:xboot.c       ****         {
 547               	1067,.LM18-.LFBB4
 548               	.LM18:
 549 0098 8881      		ld r24,Y
 550 009a 9981      		ldd r25,Y+1
 551 009c AA81      		ldd r26,Y+2
 552 009e BB81      		ldd r27,Y+3
 553 00a0 0196      		adiw r24,1
 554 00a2 A11D      		adc r26,__zero_reg__
 555 00a4 B11D      		adc r27,__zero_reg__
 556 00a6 8883      		st Y,r24
 557 00a8 9983      		std Y+1,r25
 558 00aa AA83      		std Y+2,r26
 559 00ac BB83      		std Y+3,r27
1068:xboot.c       ****  mem == MEM_PRODSIG)
 560               	1068,.LM19-.LFBB4
 561               	.LM19:
 562 00ae 0894      		sec
 563 00b0 E108      		sbc r14,__zero_reg__
 564 00b2 F108      		sbc r15,__zero_reg__
1069:xboot.c       **** _USERSIG || mem == MEM_PRODSIG)
 565               	bn	68,0,1069,.LM20-.LFBB4
 566               	.LM20:
 567 00b4 E114      		cp r14,__zero_reg__
 568 00b6 F104      		cpc r15,__zero_reg__
 569 00b8 01F4      		brne .L16
 570 00ba 00C0      		rjmp .L23
 571               	.L15:
 572               	.LBE2:
1070:xboot.c       **** _USERSIG || mem == MEM_PRODSIG)
1071:xboot.c       ****         {
1072:xboot.c       ****                 (*address) <<= 1; // Convert address to bytes temporarily.
1073:xboot.c       ****                 
 573               	68,0,1073,.LM21-.LFBB4
 574               	.LM21:
 575 00bc 6634      		cpi r22,lo8(70)
 576 00be 01F0      		breq .L18
 577 00c0 6535      		cpi r22,lo8(85)
 578 00c2 01F0      		breq .L18
 579 00c4 6035      		cpi r22,lo8(80)
 580 00c6 01F0      		breq .+2
 581 00c8 00C0      		rjmp .L23
 582               	.L18:
1074:xboot.c       **** emporarily.
1075:xboot.c       ****                 
 583               	,0,1075,.LM22-.LFBB4
 584               	.LM22:
 585 00ca 8881      		ld r24,Y
 586 00cc 9981      		ldd r25,Y+1
 587 00ce AA81      		ldd r26,Y+2
 588 00d0 BB81      		ldd r27,Y+3
 589 00d2 880F      		lsl r24
 590 00d4 991F      		rol r25
 591 00d6 AA1F      		rol r26
 592 00d8 BB1F      		rol r27
 593 00da 8883      		st Y,r24
 594 00dc 9983      		std Y+1,r25
 595 00de AA83      		std Y+2,r26
 596 00e0 BB83      		std Y+3,r27
 597               	.L22:
1076:xboot.c       **** emporarily.
1077:xboot.c       ****                 
1078:xboot.c       ****                 do
1079:xboot.c       ****                 {
 598               	79,.LM23-.LFBB4
 599               	.LM23:
 600 00e2 1634      		cpi r17,lo8(70)
 601 00e4 01F4      		brne .L19
1080:xboot.c       ****       do
1081:xboot.c       ****                 {
 602               	abn	68,0,1081,.LM24-.LFBB4
 603               	.LM24:
 604 00e6 6881      		ld r22,Y
 605 00e8 7981      		ldd r23,Y+1
 606 00ea 8A81      		ldd r24,Y+2
 607 00ec 9B81      		ldd r25,Y+3
 608 00ee 0E94 0000 		call SP_ReadByte
 609 00f2 0E94 0000 		call send_char
1082:xboot.c       ****       do
 610               	68,0,1082,.LM25-.LFBB4
 611               	.LM25:
 612 00f6 6881      		ld r22,Y
 613 00f8 7981      		ldd r23,Y+1
 614 00fa 8A81      		ldd r24,Y+2
 615 00fc 9B81      		ldd r25,Y+3
 616 00fe 6F5F      		subi r22,lo8(-(1))
 617 0100 7F4F      		sbci r23,hi8(-(1))
 618 0102 8F4F      		sbci r24,hlo8(-(1))
 619 0104 9F4F      		sbci r25,hhi8(-(1))
 620 0106 0E94 0000 		call SP_ReadByte
 621 010a 00C0      		rjmp .L26
 622               	.L19:
1083:xboot.c       ****         
1084:xboot.c       ****                 do
 623               	1084,.LM26-.LFBB4
 624               	.LM26:
 625 010c 1535      		cpi r17,lo8(85)
 626 010e 01F4      		brne .L21
1085:xboot.c       ****         
1086:xboot.c       ****                 do
 627               	abn	68,0,1086,.LM27-.LFBB4
 628               	.LM27:
 629 0110 8881      		ld r24,Y
 630 0112 9981      		ldd r25,Y+1
 631 0114 0E94 0000 		call SP_ReadUserSignatureByte
 632 0118 0E94 0000 		call send_char
1087:xboot.c       ****         
 633               	n	68,0,1087,.LM28-.LFBB4
 634               	.LM28:
 635 011c 8881      		ld r24,Y
 636 011e 9981      		ldd r25,Y+1
 637 0120 0196      		adiw r24,1
 638 0122 0E94 0000 		call SP_ReadUserSignatureByte
 639 0126 00C0      		rjmp .L26
 640               	.L21:
1088:xboot.c       **** emporarily.
1089:xboot.c       ****                 
 641               	68,0,1089,.LM29-.LFBB4
 642               	.LM29:
 643 0128 1035      		cpi r17,lo8(80)
 644 012a 01F4      		brne .L20
1090:xboot.c       **** emporarily.
1091:xboot.c       ****                 
 645               	abn	68,0,1091,.LM30-.LFBB4
 646               	.LM30:
 647 012c 8881      		ld r24,Y
 648 012e 0E94 0000 		call SP_ReadCalibrationByte
 649 0132 0E94 0000 		call send_char
1092:xboot.c       **** emporarily.
 650               	bn	68,0,1092,.LM31-.LFBB4
 651               	.LM31:
 652 0136 8881      		ld r24,Y
 653 0138 8F5F      		subi r24,lo8(-(1))
 654 013a 0E94 0000 		call SP_ReadCalibrationByte
 655               	.L26:
 656 013e 0E94 0000 		call send_char
 657               	.L20:
1093:xboot.c       **** address to bytes temporarily.
1094:xboot.c       ****                 
1095:xboot.c       ****                 do
 658               	68,0,1095,.LM32-.LFBB4
 659               	.LM32:
 660 0142 0E94 0000 		call SP_WaitForSPM
1096:xboot.c       ****         
1097:xboot.c       ****                 do
 661               	tabn	68,0,1097,.LM33-.LFBB4
 662               	.LM33:
 663 0146 8881      		ld r24,Y
 664 0148 9981      		ldd r25,Y+1
 665 014a AA81      		ldd r26,Y+2
 666 014c BB81      		ldd r27,Y+3
 667 014e 0296      		adiw r24,2
 668 0150 A11D      		adc r26,__zero_reg__
 669 0152 B11D      		adc r27,__zero_reg__
 670 0154 8883      		st Y,r24
 671 0156 9983      		std Y+1,r25
 672 0158 AA83      		std Y+2,r26
 673 015a BB83      		std Y+3,r27
1098:xboot.c       ****         
 674               	1098,.LM34-.LFBB4
 675               	.LM34:
 676 015c 2EEF      		ldi r18,lo8(-2)
 677 015e 3FEF      		ldi r19,hi8(-2)
 678 0160 E20E      		add r14,r18
 679 0162 F31E      		adc r15,r19
1099:xboot.c       **** emporarily.
 680               	n	68,0,1099,.LM35-.LFBB4
 681               	.LM35:
 682 0164 E114      		cp r14,__zero_reg__
 683 0166 F104      		cpc r15,__zero_reg__
 684 0168 01F0      		breq .+2
 685 016a 00C0      		rjmp .L22
1100:xboot.c       **** address to bytes temporarily.
1101:xboot.c       ****                 
 686               	n	68,0,1101,.LM36-.LFBB4
 687               	.LM36:
 688 016c B695      		lsr r27
 689 016e A795      		ror r26
 690 0170 9795      		ror r25
 691 0172 8795      		ror r24
 692 0174 8883      		st Y,r24
 693 0176 9983      		std Y+1,r25
 694 0178 AA83      		std Y+2,r26
 695 017a BB83      		std Y+3,r27
 696               	.L23:
 697               	/* epilogue start */
1102:xboot.c       **** emporarily.
1103:xboot.c       ****                 
 698               	,1103,.LM37-.LFBB4
 699               	.LM37:
 700 017c DF91      		pop r29
 701 017e CF91      		pop r28
 702 0180 1F91      		pop r17
 703 0182 FF90      		pop r15
 704 0184 EF90      		pop r14
 705 0186 0895      		ret
 707               	.Lscope4:
 712               	.global	BlockLoad
 714               	BlockLoad:
 716               	.LM38:
 717               	.LFBB5:
 718 0188 5F92      		push r5
 719 018a 6F92      		push r6
 720 018c 7F92      		push r7
 721 018e 8F92      		push r8
 722 0190 9F92      		push r9
 723 0192 AF92      		push r10
 724 0194 BF92      		push r11
 725 0196 CF92      		push r12
 726 0198 DF92      		push r13
 727 019a EF92      		push r14
 728 019c FF92      		push r15
 729 019e 0F93      		push r16
 730 01a0 1F93      		push r17
 731 01a2 DF93      		push r29
 732 01a4 CF93      		push r28
 733 01a6 CDB7      		in r28,__SP_L__
 734 01a8 DEB7      		in r29,__SP_H__
 735 01aa C050      		subi r28,lo8(-(-256))
 736 01ac D140      		sbci r29,hi8(-(-256))
 737 01ae CDBF      		out __SP_L__,r28
 738 01b0 DEBF      		out __SP_H__,r29
 739               	/* prologue: function */
 740               	/* frame size = 256 */
 741 01b2 3C01      		movw r6,r24
 742 01b4 562E      		mov r5,r22
 743 01b6 4A01      		movw r8,r20
 745               	.LM39:
 746 01b8 85E4      		ldi r24,lo8(69)
 747 01ba 6817      		cp r22,r24
 748 01bc 01F4      		brne .L28
 749               	.LBB3:
 751               	.LM40:
 752 01be 0E94 0000 		call EEPROM_FlushBuffer
 754               	.LM41:
 755 01c2 8091 CC01 		lds r24,460
 756 01c6 877F      		andi r24,lo8(-9)
 757 01c8 E0EC      		ldi r30,lo8(448)
 758 01ca F1E0      		ldi r31,hi8(448)
 759 01cc 8487      		std Z+12,r24
 760 01ce 7E01      		movw r14,r28
 761 01d0 0894      		sec
 762 01d2 E11C      		adc r14,__zero_reg__
 763 01d4 F11C      		adc r15,__zero_reg__
 764 01d6 6701      		movw r12,r14
 766               	.LM42:
 767 01d8 5701      		movw r10,r14
 768 01da A60C      		add r10,r6
 769 01dc B71C      		adc r11,r7
 770 01de 00C0      		rjmp .L29
 771               	.L30:
 773               	.LM43:
 774 01e0 0E94 0000 		call get_char
 775 01e4 F601      		movw r30,r12
 776 01e6 8193      		st Z+,r24
 777 01e8 6F01      		movw r12,r30
 778               	.L29:
 780               	.LM44:
 781 01ea CA14      		cp r12,r10
 782 01ec DB04      		cpc r13,r11
 783 01ee 01F4      		brne .L30
 784 01f0 00C0      		rjmp .L40
 785               	.L32:
 787               	.LM45:
 788 01f2 F401      		movw r30,r8
 789 01f4 8081      		ld r24,Z
 790 01f6 9181      		ldd r25,Z+1
 791 01f8 A281      		ldd r26,Z+2
 792 01fa B381      		ldd r27,Z+3
 794               	.LM46:
 795 01fc 682F      		mov r22,r24
 796 01fe 6F71      		andi r22,lo8(31)
 797 0200 75E0      		ldi r23,5
 798 0202 B695      	1:	lsr r27
 799 0204 A795      		ror r26
 800 0206 9795      		ror r25
 801 0208 8795      		ror r24
 802 020a 7A95      		dec r23
 803 020c 01F4      		brne 1b
 804 020e F701      		movw r30,r14
 805 0210 4191      		ld r20,Z+
 806 0212 7F01      		movw r14,r30
 807 0214 0E94 0000 		call EEPROM_WriteByte
 809               	.LM47:
 810 0218 F401      		movw r30,r8
 811 021a 8081      		ld r24,Z
 812 021c 9181      		ldd r25,Z+1
 813 021e A281      		ldd r26,Z+2
 814 0220 B381      		ldd r27,Z+3
 815 0222 0196      		adiw r24,1
 816 0224 A11D      		adc r26,__zero_reg__
 817 0226 B11D      		adc r27,__zero_reg__
 818 0228 8083      		st Z,r24
 819 022a 9183      		std Z+1,r25
 820 022c A283      		std Z+2,r26
 821 022e B383      		std Z+3,r27
 822               	.L40:
 824               	.LM48:
 825 0230 EC14      		cp r14,r12
 826 0232 FD04      		cpc r15,r13
 827 0234 01F4      		brne .L32
 828 0236 00C0      		rjmp .L41
 829               	.L28:
 830               	.LBE3:
 832               	.LM49:
 833 0238 F6E4      		ldi r31,lo8(70)
 834 023a 6F17      		cp r22,r31
 835 023c 01F0      		breq .L34
 836 023e 85E5      		ldi r24,lo8(85)
 837 0240 6817      		cp r22,r24
 838 0242 01F0      		breq .L34
 839 0244 8FE3      		ldi r24,lo8(63)
 840 0246 00C0      		rjmp .L33
 841               	.L34:
 843               	.LM50:
 844 0248 F401      		movw r30,r8
 845 024a C080      		ld r12,Z
 846 024c D180      		ldd r13,Z+1
 847 024e E280      		ldd r14,Z+2
 848 0250 F380      		ldd r15,Z+3
 849 0252 CC0C      		lsl r12
 850 0254 DD1C      		rol r13
 851 0256 EE1C      		rol r14
 852 0258 FF1C      		rol r15
 853 025a C082      		st Z,r12
 854 025c D182      		std Z+1,r13
 855 025e E282      		std Z+2,r14
 856 0260 F382      		std Z+3,r15
 857               	.L35:
 859               	.LM51:
 860 0262 0E94 0000 		call get_char
 861 0266 082F      		mov r16,r24
 862 0268 10E0      		ldi r17,lo8(0)
 864               	.LM52:
 865 026a 0E94 0000 		call get_char
 867               	.LM53:
 868 026e B82E      		mov r11,r24
 869 0270 AA24      		clr r10
 870 0272 0A29      		or r16,r10
 871 0274 1B29      		or r17,r11
 872 0276 F401      		movw r30,r8
 873 0278 8081      		ld r24,Z
 874 027a 9181      		ldd r25,Z+1
 875 027c B801      		movw r22,r16
 876 027e 0E94 0000 		call SP_LoadFlashWord
 878               	.LM54:
 879 0282 F401      		movw r30,r8
 880 0284 8081      		ld r24,Z
 881 0286 9181      		ldd r25,Z+1
 882 0288 A281      		ldd r26,Z+2
 883 028a B381      		ldd r27,Z+3
 884 028c 0296      		adiw r24,2
 885 028e A11D      		adc r26,__zero_reg__
 886 0290 B11D      		adc r27,__zero_reg__
 887 0292 8083      		st Z,r24
 888 0294 9183      		std Z+1,r25
 889 0296 A283      		std Z+2,r26
 890 0298 B383      		std Z+3,r27
 892               	.LM55:
 893 029a 8EEF      		ldi r24,lo8(-2)
 894 029c 9FEF      		ldi r25,hi8(-2)
 895 029e 680E      		add r6,r24
 896 02a0 791E      		adc r7,r25
 898               	.LM56:
 899 02a2 6114      		cp r6,__zero_reg__
 900 02a4 7104      		cpc r7,__zero_reg__
 901 02a6 01F4      		brne .L35
 903               	.LM57:
 904 02a8 96E4      		ldi r25,lo8(70)
 905 02aa 5916      		cp r5,r25
 906 02ac 01F4      		brne .L36
 908               	.LM58:
 909 02ae C701      		movw r24,r14
 910 02b0 B601      		movw r22,r12
 911 02b2 0E94 0000 		call SP_WriteApplicationPage
 912 02b6 00C0      		rjmp .L37
 913               	.L36:
 915               	.LM59:
 916 02b8 E5E5      		ldi r30,lo8(85)
 917 02ba 5E16      		cp r5,r30
 918 02bc 01F4      		brne .L37
 920               	.LM60:
 921 02be 0E94 0000 		call SP_EraseUserSignatureRow
 923               	.LM61:
 924 02c2 0E94 0000 		call SP_WaitForSPM
 926               	.LM62:
 927 02c6 0E94 0000 		call SP_WriteUserSignatureRow
 928               	.L37:
 930               	.LM63:
 931 02ca 0E94 0000 		call SP_WaitForSPM
 933               	.LM64:
 934 02ce F401      		movw r30,r8
 935 02d0 8081      		ld r24,Z
 936 02d2 9181      		ldd r25,Z+1
 937 02d4 A281      		ldd r26,Z+2
 938 02d6 B381      		ldd r27,Z+3
 939 02d8 B695      		lsr r27
 940 02da A795      		ror r26
 941 02dc 9795      		ror r25
 942 02de 8795      		ror r24
 943 02e0 8083      		st Z,r24
 944 02e2 9183      		std Z+1,r25
 945 02e4 A283      		std Z+2,r26
 946 02e6 B383      		std Z+3,r27
 947               	.L41:
 948 02e8 8DE0      		ldi r24,lo8(13)
 949               	.L33:
 950               	/* epilogue start */
 952               	.LM65:
 953 02ea C050      		subi r28,lo8(-(256))
 954 02ec DF4F      		sbci r29,hi8(-(256))
 955 02ee CDBF      		out __SP_L__,r28
 956 02f0 DEBF      		out __SP_H__,r29
 957 02f2 CF91      		pop r28
 958 02f4 DF91      		pop r29
 959 02f6 1F91      		pop r17
 960 02f8 0F91      		pop r16
 961 02fa FF90      		pop r15
 962 02fc EF90      		pop r14
 963 02fe DF90      		pop r13
 964 0300 CF90      		pop r12
 965 0302 BF90      		pop r11
 966 0304 AF90      		pop r10
 967 0306 9F90      		pop r9
 968 0308 8F90      		pop r8
 969 030a 7F90      		pop r7
 970 030c 6F90      		pop r6
 971 030e 5F90      		pop r5
 972 0310 0895      		ret
 980               	.Lscope5:
 982               	.global	main
 984               	main:
 986               	.LM66:
 987               	.LFBB6:
 988 0312 3F92      		push r3
 989 0314 4F92      		push r4
 990 0316 5F92      		push r5
 991 0318 6F92      		push r6
 992 031a 7F92      		push r7
 993 031c 8F92      		push r8
 994 031e 9F92      		push r9
 995 0320 AF92      		push r10
 996 0322 BF92      		push r11
 997 0324 CF92      		push r12
 998 0326 DF92      		push r13
 999 0328 EF92      		push r14
 1000 032a FF92      		push r15
 1001 032c 0F93      		push r16
 1002 032e 1F93      		push r17
 1003 0330 DF93      		push r29
 1004 0332 CF93      		push r28
 1005 0334 CDB7      		in r28,__SP_L__
 1006 0336 DEB7      		in r29,__SP_H__
 1007 0338 2597      		sbiw r28,5
 1008 033a CDBF      		out __SP_L__,r28
 1009 033c DEBF      		out __SP_H__,r29
 1010               	/* prologue: function */
 1011               	/* frame size = 5 */
 1013               	.LM67:
 1014 033e 1092 0000 		sts comm_mode,__zero_reg__
 1016               	.LM68:
 1017 0342 8091 5000 		lds r24,80
 1018 0346 8260      		ori r24,lo8(2)
 1019 0348 8093 5000 		sts 80,r24
 1020               	.L43:
 1022               	.LM69:
 1023 034c 8091 5100 		lds r24,81
 1024 0350 81FF      		sbrs r24,1
 1025 0352 00C0      		rjmp .L43
 1027               	.LM70:
 1028 0354 88ED      		ldi r24,lo8(-40)
 1029 0356 84BF      		out 52-0,r24
 1031               	.LM71:
 1032 0358 81E0      		ldi r24,lo8(1)
 1033 035a 8093 4000 		sts 64,r24
 1035               	.LM72:
 1036 035e 8093 6000 		sts 96,r24
 1038               	.LM73:
 1039 0362 E0E6      		ldi r30,lo8(1632)
 1040 0364 F6E0      		ldi r31,hi8(1632)
 1041 0366 82E0      		ldi r24,lo8(2)
 1042 0368 8183      		std Z+1,r24
 1044               	.LM74:
 1045 036a 8583      		std Z+5,r24
 1047               	.LM75:
 1048 036c E0E8      		ldi r30,lo8(1664)
 1049 036e F6E0      		ldi r31,hi8(1664)
 1050 0370 84E0      		ldi r24,lo8(4)
 1051 0372 8283      		std Z+2,r24
 1053               	.LM76:
 1054 0374 88E1      		ldi r24,lo8(24)
 1055 0376 828B      		std Z+18,r24
 1057               	.LM77:
 1058 0378 1982      		std Y+1,__zero_reg__
 1060               	.LM78:
 1061 037a 1A82      		std Y+2,__zero_reg__
 1062 037c 1B82      		std Y+3,__zero_reg__
 1063 037e 1C82      		std Y+4,__zero_reg__
 1064 0380 1D82      		std Y+5,__zero_reg__
 1066               	.LM79:
 1067 0382 0E94 0000 		call uart_init
 1069               	.LM80:
 1070               	/* #APP */
 1071               	 ;  189 "xboot.c" 1
 1072 0386 0000      		nop
 1073               	 ;  0 "" 2
 1075               	.LM81:
 1076               	 ;  190 "xboot.c" 1
 1077 0388 0000      		nop
 1078               	 ;  0 "" 2
 1080               	.LM82:
 1081               	 ;  191 "xboot.c" 1
 1082 038a 0000      		nop
 1083               	 ;  0 "" 2
 1085               	.LM83:
 1086               	 ;  192 "xboot.c" 1
 1087 038c 0000      		nop
 1088               	 ;  0 "" 2
 1090               	.LM84:
 1091               	/* #NOAPP */
 1092 038e 1091 8806 		lds r17,1672
 1093 0392 1695      		lsr r17
 1094 0394 1695      		lsr r17
 1095 0396 1095      		com r17
 1096 0398 1170      		andi r17,lo8(1)
 1098               	.LM85:
 1099 039a 20E6      		ldi r18,lo8(1632)
 1100 039c 422E      		mov r4,r18
 1101 039e 26E0      		ldi r18,hi8(1632)
 1102 03a0 522E      		mov r5,r18
 1103 03a2 92E0      		ldi r25,lo8(2)
 1104 03a4 392E      		mov r3,r25
 1106               	.LM86:
 1107 03a6 82E0      		ldi r24,lo8(2)
 1108 03a8 882E      		mov r8,r24
 1109 03aa 912C      		mov r9,__zero_reg__
 1110 03ac 8C0E      		add r8,r28
 1111 03ae 9D1E      		adc r9,r29
 1113               	.LM87:
 1114 03b0 3E01      		movw r6,r28
 1115 03b2 0894      		sec
 1116 03b4 611C      		adc r6,__zero_reg__
 1117 03b6 711C      		adc r7,__zero_reg__
 1118 03b8 00C0      		rjmp .L44
 1119               	.L76:
 1121               	.LM88:
 1122 03ba F201      		movw r30,r4
 1123 03bc 3782      		std Z+7,r3
 1125               	.LM89:
 1126 03be 0E94 0000 		call get_char
 1127 03c2 982F      		mov r25,r24
 1128 03c4 8983      		std Y+1,r24
 1130               	.LM90:
 1131 03c6 8136      		cpi r24,lo8(97)
 1132 03c8 01F4      		brne .L45
 1134               	.LM91:
 1135 03ca 89E5      		ldi r24,lo8(89)
 1136 03cc 00C0      		rjmp .L79
 1137               	.L45:
 1139               	.LM92:
 1140 03ce 8134      		cpi r24,lo8(65)
 1141 03d0 01F4      		brne .L47
 1143               	.LM93:
 1144 03d2 0E94 0000 		call get_2bytes
 1145 03d6 A0E0      		ldi r26,lo8(0)
 1146 03d8 B0E0      		ldi r27,hi8(0)
 1147 03da 00C0      		rjmp .L87
 1148               	.L47:
 1150               	.LM94:
 1151 03dc 8834      		cpi r24,lo8(72)
 1152 03de 01F4      		brne .L48
 1154               	.LM95:
 1155               	/* #APP */
 1156               	 ;  295 "xboot.c" 1
 1157 03e0 0E94 0000 		call get_char
 1158 03e4 A82F      		mov  r26,r24
 1159 03e6 0E94 0000 		call get_2bytes
 1160 03ea BB27      		clr  r27
 1161               		
 1162               	 ;  0 "" 2
 1163               	/* #NOAPP */
 1164               	.L87:
 1165 03ec 8A83      		std Y+2,r24
 1166 03ee 9B83      		std Y+3,r25
 1167 03f0 AC83      		std Y+4,r26
 1168 03f2 BD83      		std Y+5,r27
 1169 03f4 00C0      		rjmp .L84
 1170               	.L48:
 1172               	.LM96:
 1173 03f6 8536      		cpi r24,lo8(101)
 1174 03f8 01F4      		brne .L49
 1176               	.LM97:
 1177 03fa 0E94 0000 		call SP_EraseApplicationSection
 1179               	.LM98:
 1180 03fe 0E94 0000 		call SP_WaitForSPM
 1182               	.LM99:
 1183 0402 C301      		movw r24,r6
 1184 0404 0E94 0000 		call EEPROM_LoadPage
 1186               	.LM100:
 1187 0408 0E94 0000 		call EEPROM_EraseAll
 1188               	.L84:
 1190               	.LM101:
 1191 040c 8DE0      		ldi r24,lo8(13)
 1192 040e 00C0      		rjmp .L79
 1193               	.L49:
 1195               	.LM102:
 1196 0410 8236      		cpi r24,lo8(98)
 1197 0412 01F4      		brne .L50
 1199               	.LM103:
 1200 0414 89E5      		ldi r24,lo8(89)
 1201 0416 0E94 0000 		call send_char
 1203               	.LM104:
 1204 041a 81E0      		ldi r24,lo8(1)
 1205 041c 00C0      		rjmp .L85
 1206               	.L50:
 1208               	.LM105:
 1209 041e 8234      		cpi r24,lo8(66)
 1210 0420 01F4      		brne .L51
 1212               	.LM106:
 1213 0422 0E94 0000 		call get_2bytes
 1214 0426 182F      		mov r17,r24
 1215 0428 092F      		mov r16,r25
 1216 042a 282F      		mov r18,r24
 1217 042c 392F      		mov r19,r25
 1218 042e C901      		movw r24,r18
 1219 0430 6C01      		movw r12,r24
 1221               	.LM107:
 1222 0432 0E94 0000 		call get_char
 1223 0436 682F      		mov r22,r24
 1224 0438 8983      		std Y+1,r24
 1226               	.LM108:
 1227 043a 812F      		mov r24,r17
 1228 043c 902F      		mov r25,r16
 1229 043e A401      		movw r20,r8
 1230 0440 0E94 0000 		call BlockLoad
 1231 0444 00C0      		rjmp .L79
 1232               	.L51:
 1234               	.LM109:
 1235 0446 8736      		cpi r24,lo8(103)
 1236 0448 01F4      		brne .L52
 1238               	.LM110:
 1239 044a 0E94 0000 		call get_2bytes
 1240 044e 182F      		mov r17,r24
 1241 0450 092F      		mov r16,r25
 1242 0452 282F      		mov r18,r24
 1243 0454 392F      		mov r19,r25
 1244 0456 C901      		movw r24,r18
 1245 0458 6C01      		movw r12,r24
 1247               	.LM111:
 1248 045a 0E94 0000 		call get_char
 1249 045e 682F      		mov r22,r24
 1250 0460 8983      		std Y+1,r24
 1252               	.LM112:
 1253 0462 812F      		mov r24,r17
 1254 0464 902F      		mov r25,r16
 1255 0466 A401      		movw r20,r8
 1256 0468 0E94 0000 		call BlockRead
 1257 046c 00C0      		rjmp .L80
 1258               	.L52:
 1260               	.LM113:
 1261 046e 8235      		cpi r24,lo8(82)
 1262 0470 01F4      		brne .L53
 1264               	.LM114:
 1265 0472 6A81      		ldd r22,Y+2
 1266 0474 7B81      		ldd r23,Y+3
 1267 0476 8C81      		ldd r24,Y+4
 1268 0478 9D81      		ldd r25,Y+5
 1269 047a 660F      		lsl r22
 1270 047c 771F      		rol r23
 1271 047e 881F      		rol r24
 1272 0480 991F      		rol r25
 1273 0482 6F5F      		subi r22,lo8(-(1))
 1274 0484 7F4F      		sbci r23,hi8(-(1))
 1275 0486 8F4F      		sbci r24,hlo8(-(1))
 1276 0488 9F4F      		sbci r25,hhi8(-(1))
 1277 048a 0E94 0000 		call SP_ReadByte
 1278 048e 0E94 0000 		call send_char
 1280               	.LM115:
 1281 0492 6A81      		ldd r22,Y+2
 1282 0494 7B81      		ldd r23,Y+3
 1283 0496 8C81      		ldd r24,Y+4
 1284 0498 9D81      		ldd r25,Y+5
 1285 049a 660F      		lsl r22
 1286 049c 771F      		rol r23
 1287 049e 881F      		rol r24
 1288 04a0 991F      		rol r25
 1289 04a2 0E94 0000 		call SP_ReadByte
 1290 04a6 00C0      		rjmp .L81
 1291               	.L53:
 1293               	.LM116:
 1294 04a8 8336      		cpi r24,lo8(99)
 1295 04aa 01F4      		brne .L54
 1297               	.LM117:
 1298 04ac 0E94 0000 		call get_char
 1299 04b0 C82E      		mov r12,r24
 1300 04b2 DD24      		clr r13
 1301 04b4 00C0      		rjmp .L84
 1302               	.L54:
 1304               	.LM118:
 1305 04b6 8334      		cpi r24,lo8(67)
 1306 04b8 01F4      		brne .L55
 1308               	.LM119:
 1309 04ba 0E94 0000 		call get_char
 1310 04be B82E      		mov r11,r24
 1311 04c0 AA24      		clr r10
 1312 04c2 CA28      		or r12,r10
 1313 04c4 DB28      		or r13,r11
 1315               	.LM120:
 1316 04c6 8A81      		ldd r24,Y+2
 1317 04c8 9B81      		ldd r25,Y+3
 1318 04ca 880F      		lsl r24
 1319 04cc 991F      		rol r25
 1320 04ce B601      		movw r22,r12
 1321 04d0 0E94 0000 		call SP_LoadFlashWord
 1323               	.LM121:
 1324 04d4 8A81      		ldd r24,Y+2
 1325 04d6 9B81      		ldd r25,Y+3
 1326 04d8 AC81      		ldd r26,Y+4
 1327 04da BD81      		ldd r27,Y+5
 1328 04dc 0196      		adiw r24,1
 1329 04de A11D      		adc r26,__zero_reg__
 1330 04e0 B11D      		adc r27,__zero_reg__
 1331 04e2 00C0      		rjmp .L87
 1332               	.L55:
 1334               	.LM122:
 1335 04e4 8D36      		cpi r24,lo8(109)
 1336 04e6 01F4      		brne .L56
 1338               	.LM123:
 1339 04e8 6A81      		ldd r22,Y+2
 1340 04ea 7B81      		ldd r23,Y+3
 1341 04ec 8C81      		ldd r24,Y+4
 1342 04ee 9D81      		ldd r25,Y+5
 1343 04f0 6030      		cpi r22,lo8(8192)
 1344 04f2 F0E2      		ldi r31,hi8(8192)
 1345 04f4 7F07      		cpc r23,r31
 1346 04f6 F0E0      		ldi r31,hlo8(8192)
 1347 04f8 8F07      		cpc r24,r31
 1348 04fa F0E0      		ldi r31,hhi8(8192)
 1349 04fc 9F07      		cpc r25,r31
 1350 04fe 00F0      		brlo .+2
 1351 0500 00C0      		rjmp .L75
 1352               	.L57:
 1354               	.LM124:
 1355 0502 660F      		lsl r22
 1356 0504 771F      		rol r23
 1357 0506 881F      		rol r24
 1358 0508 991F      		rol r25
 1359 050a 0E94 0000 		call SP_WriteApplicationPage
 1360 050e 00C0      		rjmp .L84
 1361               	.L56:
 1363               	.LM125:
 1364 0510 8434      		cpi r24,lo8(68)
 1365 0512 01F4      		brne .L58
 1367               	.LM126:
 1368 0514 EA80      		ldd r14,Y+2
 1369 0516 FB80      		ldd r15,Y+3
 1370 0518 0C81      		ldd r16,Y+4
 1371 051a 1D81      		ldd r17,Y+5
 1372 051c 0E94 0000 		call get_char
 1373 0520 482F      		mov r20,r24
 1374 0522 6E2D      		mov r22,r14
 1375 0524 6F71      		andi r22,lo8(31)
 1376 0526 F5E0      		ldi r31,5
 1377 0528 1695      	1:	lsr r17
 1378 052a 0795      		ror r16
 1379 052c F794      		ror r15
 1380 052e E794      		ror r14
 1381 0530 FA95      		dec r31
 1382 0532 01F4      		brne 1b
 1383 0534 8E2D      		mov r24,r14
 1384 0536 0E94 0000 		call EEPROM_WriteByte
 1385 053a 00C0      		rjmp .L82
 1386               	.L58:
 1388               	.LM127:
 1389 053c 8436      		cpi r24,lo8(100)
 1390 053e 01F4      		brne .L59
 1392               	.LM128:
 1393 0540 8A81      		ldd r24,Y+2
 1394 0542 9B81      		ldd r25,Y+3
 1395 0544 AC81      		ldd r26,Y+4
 1396 0546 BD81      		ldd r27,Y+5
 1397 0548 682F      		mov r22,r24
 1398 054a 6F71      		andi r22,lo8(31)
 1399 054c E5E0      		ldi r30,5
 1400 054e B695      	1:	lsr r27
 1401 0550 A795      		ror r26
 1402 0552 9795      		ror r25
 1403 0554 8795      		ror r24
 1404 0556 EA95      		dec r30
 1405 0558 01F4      		brne 1b
 1406 055a 0E94 0000 		call EEPROM_ReadByte
 1407               	.L81:
 1408 055e 0E94 0000 		call send_char
 1409               	.L82:
 1411               	.LM129:
 1412 0562 8A81      		ldd r24,Y+2
 1413 0564 9B81      		ldd r25,Y+3
 1414 0566 AC81      		ldd r26,Y+4
 1415 0568 BD81      		ldd r27,Y+5
 1416 056a 0196      		adiw r24,1
 1417 056c A11D      		adc r26,__zero_reg__
 1418 056e B11D      		adc r27,__zero_reg__
 1419 0570 8A83      		std Y+2,r24
 1420 0572 9B83      		std Y+3,r25
 1421 0574 AC83      		std Y+4,r26
 1422 0576 BD83      		std Y+5,r27
 1423 0578 00C0      		rjmp .L80
 1424               	.L59:
 1426               	.LM130:
 1427 057a 8C36      		cpi r24,lo8(108)
 1428 057c 01F4      		brne .L60
 1430               	.LM131:
 1431 057e 0E94 0000 		call get_char
 1432 0582 0E94 0000 		call SP_WriteLockBits
 1433 0586 00C0      		rjmp .L84
 1434               	.L60:
 1436               	.LM132:
 1437 0588 8237      		cpi r24,lo8(114)
 1438 058a 01F4      		brne .L61
 1440               	.LM133:
 1441 058c 0E94 0000 		call SP_ReadLockBits
 1442 0590 00C0      		rjmp .L79
 1443               	.L61:
 1445               	.LM134:
 1446 0592 8634      		cpi r24,lo8(70)
 1447 0594 01F4      		brne .L62
 1449               	.LM135:
 1450 0596 80E0      		ldi r24,lo8(0)
 1451 0598 00C0      		rjmp .L86
 1452               	.L62:
 1454               	.LM136:
 1455 059a 8E34      		cpi r24,lo8(78)
 1456 059c 01F4      		brne .L63
 1458               	.LM137:
 1459 059e 81E0      		ldi r24,lo8(1)
 1460 05a0 00C0      		rjmp .L86
 1461               	.L63:
 1463               	.LM138:
 1464 05a2 8135      		cpi r24,lo8(81)
 1465 05a4 01F4      		brne .L64
 1467               	.LM139:
 1468 05a6 82E0      		ldi r24,lo8(2)
 1469               	.L86:
 1470 05a8 0E94 0000 		call SP_ReadFuseByte
 1471 05ac 00C0      		rjmp .L79
 1472               	.L64:
 1474               	.LM140:
 1475 05ae 8035      		cpi r24,lo8(80)
 1476 05b0 01F4      		brne .+2
 1477 05b2 00C0      		rjmp .L84
 1478 05b4 8C34      		cpi r24,lo8(76)
 1479 05b6 01F4      		brne .+2
 1480 05b8 00C0      		rjmp .L84
 1481               	.L66:
 1483               	.LM141:
 1484 05ba 8534      		cpi r24,lo8(69)
 1485 05bc 01F4      		brne .L67
 1487               	.LM142:
 1488 05be 8DE0      		ldi r24,lo8(13)
 1489 05c0 0E94 0000 		call send_char
 1490 05c4 10E0      		ldi r17,lo8(0)
 1491 05c6 00C0      		rjmp .L46
 1492               	.L67:
 1494               	.LM143:
 1495 05c8 8037      		cpi r24,lo8(112)
 1496 05ca 01F4      		brne .L68
 1498               	.LM144:
 1499 05cc 83E5      		ldi r24,lo8(83)
 1500 05ce 00C0      		rjmp .L79
 1501               	.L68:
 1503               	.LM145:
 1504 05d0 8437      		cpi r24,lo8(116)
 1505 05d2 01F4      		brne .L69
 1507               	.LM146:
 1508 05d4 8BE7      		ldi r24,lo8(123)
 1509               	.L85:
 1510 05d6 0E94 0000 		call send_char
 1512               	.LM147:
 1513 05da 80E0      		ldi r24,lo8(0)
 1514 05dc 00C0      		rjmp .L79
 1515               	.L69:
 1517               	.LM148:
 1518 05de 8857      		subi r24,lo8(-(-120))
 1519 05e0 8230      		cpi r24,lo8(2)
 1520 05e2 00F0      		brlo .L70
 1521 05e4 9435      		cpi r25,lo8(84)
 1522 05e6 01F4      		brne .L71
 1523               	.L70:
 1525               	.LM149:
 1526 05e8 0E94 0000 		call get_char
 1527 05ec 00C0      		rjmp .L84
 1528               	.L71:
 1530               	.LM150:
 1531 05ee 9335      		cpi r25,lo8(83)
 1532 05f0 01F4      		brne .L72
 1534               	.LM151:
 1535 05f2 88E5      		ldi r24,lo8(88)
 1536 05f4 0E94 0000 		call send_char
 1538               	.LM152:
 1539 05f8 82E4      		ldi r24,lo8(66)
 1540 05fa 0E94 0000 		call send_char
 1542               	.LM153:
 1543 05fe 8FE6      		ldi r24,lo8(111)
 1544 0600 0E94 0000 		call send_char
 1546               	.LM154:
 1547 0604 8FE6      		ldi r24,lo8(111)
 1548 0606 0E94 0000 		call send_char
 1550               	.LM155:
 1551 060a 84E7      		ldi r24,lo8(116)
 1552 060c 0E94 0000 		call send_char
 1554               	.LM156:
 1555 0610 8BE2      		ldi r24,lo8(43)
 1556 0612 0E94 0000 		call send_char
 1558               	.LM157:
 1559 0616 8BE2      		ldi r24,lo8(43)
 1560 0618 00C0      		rjmp .L79
 1561               	.L72:
 1563               	.LM158:
 1564 061a 9635      		cpi r25,lo8(86)
 1565 061c 01F4      		brne .L73
 1567               	.LM159:
 1568 061e 81E3      		ldi r24,lo8(49)
 1569 0620 0E94 0000 		call send_char
 1571               	.LM160:
 1572 0624 86E3      		ldi r24,lo8(54)
 1573 0626 00C0      		rjmp .L79
 1574               	.L73:
 1576               	.LM161:
 1577 0628 9337      		cpi r25,lo8(115)
 1578 062a 01F4      		brne .L74
 1580               	.LM162:
 1581 062c 81E4      		ldi r24,lo8(65)
 1582 062e 0E94 0000 		call send_char
 1584               	.LM163:
 1585 0632 84E9      		ldi r24,lo8(-108)
 1586 0634 0E94 0000 		call send_char
 1588               	.LM164:
 1589 0638 8EE1      		ldi r24,lo8(30)
 1590 063a 00C0      		rjmp .L79
 1591               	.L74:
 1593               	.LM165:
 1594 063c 9B31      		cpi r25,lo8(27)
 1595 063e 01F0      		breq .L80
 1596               	.L75:
 1598               	.LM166:
 1599 0640 8FE3      		ldi r24,lo8(63)
 1600               	.L79:
 1601 0642 0E94 0000 		call send_char
 1602               	.L80:
 1603 0646 11E0      		ldi r17,lo8(1)
 1604               	.L46:
 1606               	.LM167:
 1607 0648 0E94 0000 		call SP_WaitForSPM
 1608               	.L44:
 1610               	.LM168:
 1611 064c 1123      		tst r17
 1612 064e 01F0      		breq .+2
 1613 0650 00C0      		rjmp .L76
 1615               	.LM169:
 1616 0652 0E94 0000 		call uart_deinit
 1618               	.LM170:
 1619 0656 82E0      		ldi r24,lo8(2)
 1620 0658 E0E6      		ldi r30,lo8(1632)
 1621 065a F6E0      		ldi r31,hi8(1632)
 1622 065c 8283      		std Z+2,r24
 1624               	.LM171:
 1625 065e 1CBE      		out 60-0,__zero_reg__
 1627               	.LM172:
 1628 0660 E0E0      		ldi r30,lo8(0)
 1629 0662 F0E0      		ldi r31,hi8(0)
 1630 0664 0995      		icall
 1632               	.LM173:
 1633 0666 80E0      		ldi r24,lo8(0)
 1634 0668 90E0      		ldi r25,hi8(0)
 1635               	/* epilogue start */
 1636 066a 2596      		adiw r28,5
 1637 066c CDBF      		out __SP_L__,r28
 1638 066e DEBF      		out __SP_H__,r29
 1639 0670 CF91      		pop r28
 1640 0672 DF91      		pop r29
 1641 0674 1F91      		pop r17
 1642 0676 0F91      		pop r16
 1643 0678 FF90      		pop r15
 1644 067a EF90      		pop r14
 1645 067c DF90      		pop r13
 1646 067e CF90      		pop r12
 1647 0680 BF90      		pop r11
 1648 0682 AF90      		pop r10
 1649 0684 9F90      		pop r9
 1650 0686 8F90      		pop r8
 1651 0688 7F90      		pop r7
 1652 068a 6F90      		pop r6
 1653 068c 5F90      		pop r5
 1654 068e 4F90      		pop r4
 1655 0690 3F90      		pop r3
 1656 0692 0895      		ret
 1664               	.Lscope6:
 1665               		.comm comm_mode,1,1
 1668               	.Letext0:
 1669               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 xboot.c
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:2      *ABS*:0000003f __SREG__
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:3      *ABS*:0000003e __SP_H__
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:4      *ABS*:0000003d __SP_L__
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:5      *ABS*:00000034 __CCP__
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:7      *ABS*:00000001 __zero_reg__
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:397    .text:00000000 get_char
                            *COM*:00000001 comm_mode
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:434    .text:0000001e send_char
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:465    .text:00000042 get_2bytes
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:498    .text:00000052 BlockRead
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:714    .text:00000188 BlockLoad
C:\Users\tlauwers\AppData\Local\Temp/ccN1Pscw.s:984    .text:00000312 main

UNDEFINED SYMBOLS
EEPROM_FlushBuffer
EEPROM_ReadByte
SP_ReadByte
SP_ReadUserSignatureByte
SP_ReadCalibrationByte
SP_WaitForSPM
EEPROM_WriteByte
SP_LoadFlashWord
SP_WriteApplicationPage
SP_EraseUserSignatureRow
SP_WriteUserSignatureRow
uart_init
SP_EraseApplicationSection
EEPROM_LoadPage
EEPROM_EraseAll
SP_WriteLockBits
SP_ReadLockBits
SP_ReadFuseByte
uart_deinit
__do_clear_bss
