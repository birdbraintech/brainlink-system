   1               		.file	"eeprom_driver.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 399               	.global	EEPROM_ReadByte
 401               	EEPROM_ReadByte:
   1:eeprom_driver.c **** /* This file has been prepared for Doxygen automatic documentation generation.*/
   2:eeprom_driver.c **** /*! \file *********************************************************************
   3:eeprom_driver.c ****  *
   4:eeprom_driver.c ****  * \brief  XMEGA EEPROM driver source file.
   5:eeprom_driver.c ****  *
   6:eeprom_driver.c ****  *      This file contains the function implementations for the XMEGA EEPROM driver.
   7:eeprom_driver.c ****  *
   8:eeprom_driver.c ****  *      The driver is not intended for size and/or speed critical code, since
   9:eeprom_driver.c ****  *      most functions are just a few lines of code, and the function call
  10:eeprom_driver.c ****  *      overhead would decrease code performance. The driver is intended for
  11:eeprom_driver.c ****  *      rapid prototyping and documentation purposes for getting started with
  12:eeprom_driver.c ****  *      the XMEGA EEPROM module.
  13:eeprom_driver.c ****  *
  14:eeprom_driver.c ****  *      For size and/or speed critical code, it is recommended to copy the
  15:eeprom_driver.c ****  *      function contents directly into your application instead of making
  16:eeprom_driver.c ****  *      a function call.
  17:eeprom_driver.c ****  *
  18:eeprom_driver.c ****  * \par Application note:
  19:eeprom_driver.c ****  *      AVR1315: Accessing the XMEGA EEPROM
  20:eeprom_driver.c ****  *
  21:eeprom_driver.c ****  * \par Documentation
  22:eeprom_driver.c ****  *      For comprehensive code documentation, supported compilers, compiler
  23:eeprom_driver.c ****  *      settings and supported devices see readme.html
  24:eeprom_driver.c ****  *
  25:eeprom_driver.c ****  * \author
  26:eeprom_driver.c ****  *      Atmel Corporation: http://www.atmel.com \n
  27:eeprom_driver.c ****  *      Support email: avr@atmel.com
  28:eeprom_driver.c ****  *
  29:eeprom_driver.c ****  * $Revision: 1 $
  30:eeprom_driver.c ****  * $Date: 2009-04-22 13:03:43 +0200 (ti, 22 apr 2009) $  \n
  31:eeprom_driver.c ****  *
  32:eeprom_driver.c ****  * Copyright (c) 2009, Atmel Corporation All rights reserved.
  33:eeprom_driver.c ****  *
  34:eeprom_driver.c ****  * Redistribution and use in source and binary forms, with or without
  35:eeprom_driver.c ****  * modification, are permitted provided that the following conditions are met:
  36:eeprom_driver.c ****  *
  37:eeprom_driver.c ****  * 1. Redistributions of source code must retain the above copyright notice,
  38:eeprom_driver.c ****  * this list of conditions and the following disclaimer.
  39:eeprom_driver.c ****  *
  40:eeprom_driver.c ****  * 2. Redistributions in binary form must reproduce the above copyright notice,
  41:eeprom_driver.c ****  * this list of conditions and the following disclaimer in the documentation
  42:eeprom_driver.c ****  * and/or other materials provided with the distribution.
  43:eeprom_driver.c ****  *
  44:eeprom_driver.c ****  * 3. The name of ATMEL may not be used to endorse or promote products derived
  45:eeprom_driver.c ****  * from this software without specific prior written permission.
  46:eeprom_driver.c ****  *
  47:eeprom_driver.c ****  * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
  48:eeprom_driver.c ****  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  49:eeprom_driver.c ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
  50:eeprom_driver.c ****  * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
  51:eeprom_driver.c ****  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  52:eeprom_driver.c ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  53:eeprom_driver.c ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  54:eeprom_driver.c ****  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  55:eeprom_driver.c ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  56:eeprom_driver.c ****  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  57:eeprom_driver.c ****  *****************************************************************************/
  58:eeprom_driver.c **** 
  59:eeprom_driver.c **** #include "eeprom_driver.h"
  60:eeprom_driver.c **** 
  61:eeprom_driver.c **** static inline void NVM_EXEC(void)
  62:eeprom_driver.c **** {
  63:eeprom_driver.c ****         void *z = (void *)&NVM_CTRLA;
  64:eeprom_driver.c ****         
  65:eeprom_driver.c ****         __asm__ volatile("out %[ccp], %[ioreg]"  "\n\t"
  66:eeprom_driver.c ****         "st z, %[cmdex]"
  67:eeprom_driver.c ****         :
  68:eeprom_driver.c ****         : [ccp] "I" (_SFR_IO_ADDR(CCP)),
  69:eeprom_driver.c ****         [ioreg] "d" (CCP_IOREG_gc),
  70:eeprom_driver.c ****                      [cmdex] "r" (NVM_CMDEX_bm),
  71:eeprom_driver.c ****                      [z] "z" (z)
  72:eeprom_driver.c ****                      );
  73:eeprom_driver.c **** }
  74:eeprom_driver.c **** 
  75:eeprom_driver.c **** #ifdef USE_AVR1008_EEPROM
  76:eeprom_driver.c **** 
  77:eeprom_driver.c **** // Interrupt handler for the EEPROM write "done" interrupt
  78:eeprom_driver.c **** ISR(NVM_EE_vect)
  79:eeprom_driver.c **** {
  80:eeprom_driver.c ****         // Disable the EEPROM interrupt
  81:eeprom_driver.c ****         NVM.INTCTRL = (NVM.INTCTRL & ~NVM_EELVL_gm);
  82:eeprom_driver.c **** }
  83:eeprom_driver.c **** 
  84:eeprom_driver.c **** // AVR1008 fix
  85:eeprom_driver.c **** static inline void NVM_EXEC_WRAPPER(void)
  86:eeprom_driver.c **** {
  87:eeprom_driver.c ****         // Save the Sleep register
  88:eeprom_driver.c ****         uint8_t sleepCtr = SLEEP.CTRL;
  89:eeprom_driver.c ****         // Set sleep mode to IDLE
  90:eeprom_driver.c ****         SLEEP.CTRL = (SLEEP.CTRL & ~SLEEP.CTRL) | SLEEP_SMODE_IDLE_gc;
  91:eeprom_driver.c ****         // Save the PMIC Status and control registers
  92:eeprom_driver.c ****         uint8_t statusStore = PMIC.STATUS;
  93:eeprom_driver.c ****         uint8_t pmicStore = PMIC.CTRL;
  94:eeprom_driver.c ****         
  95:eeprom_driver.c ****         // Enable only the highest level of interrupts
  96:eeprom_driver.c ****         PMIC.CTRL = (PMIC.CTRL & ~(PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm)) | PMIC_HILVLEN_bm;
  97:eeprom_driver.c ****         // Save SREG for later use
  98:eeprom_driver.c ****         uint8_t globalInt = SREG;
  99:eeprom_driver.c ****         // Enable global interrupts
 100:eeprom_driver.c ****         sei();
 101:eeprom_driver.c ****         // Set sleep enabled
 102:eeprom_driver.c ****         SLEEP.CTRL |= SLEEP_SEN_bm;
 103:eeprom_driver.c ****         // Save eeprom interrupt settings for later
 104:eeprom_driver.c ****         uint8_t eepromintStore = NVM.INTCTRL;
 105:eeprom_driver.c ****         NVM_EXEC();
 106:eeprom_driver.c ****         // Enable EEPROM interrupt
 107:eeprom_driver.c ****         NVM.INTCTRL =  NVM_EELVL0_bm | NVM_EELVL1_bm;
 108:eeprom_driver.c ****         // Sleep before 2.5uS has passed
 109:eeprom_driver.c ****         sleep_cpu();
 110:eeprom_driver.c ****         // Restore sleep settings
 111:eeprom_driver.c ****         SLEEP.CTRL = sleepCtr;
 112:eeprom_driver.c ****         // Restore PMIC status and control registers
 113:eeprom_driver.c ****         PMIC.STATUS = statusStore;
 114:eeprom_driver.c ****         PMIC.CTRL = pmicStore;
 115:eeprom_driver.c ****         // Restore EEPROM interruptsettings
 116:eeprom_driver.c ****         NVM.INTCTRL = eepromintStore;
 117:eeprom_driver.c ****         // Restore global interrupt settings
 118:eeprom_driver.c ****         SREG = globalInt;
 119:eeprom_driver.c **** }
 120:eeprom_driver.c **** 
 121:eeprom_driver.c **** #else
 122:eeprom_driver.c **** 
 123:eeprom_driver.c **** #define NVM_EXEC_WRAPPER NVM_EXEC
 124:eeprom_driver.c **** 
 125:eeprom_driver.c **** #endif // USE_AVR1008_EEPROM
 126:eeprom_driver.c **** 
 127:eeprom_driver.c **** /*! \brief Write one byte to EEPROM using IO mapping.
 128:eeprom_driver.c ****  *
 129:eeprom_driver.c ****  *  This function writes one byte to EEPROM using IO-mapped access.
 130:eeprom_driver.c ****  *  Please note that the memory mapped EERPROM can not be used when using this function.
 131:eeprom_driver.c ****  *  This functiom will cancel all ongoing EEPROM page buffer loading
 132:eeprom_driver.c ****  *  operations, if any.
 133:eeprom_driver.c ****  *
 134:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 135:eeprom_driver.c ****  *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE.
 136:eeprom_driver.c ****  *  \param  value     Byte value to write to EEPROM.
 137:eeprom_driver.c ****  */
 138:eeprom_driver.c **** void EEPROM_WriteByte( uint8_t pageAddr, uint8_t byteAddr, uint8_t value )
 139:eeprom_driver.c **** {
 140:eeprom_driver.c **** 	/*  Flush buffer to make sure no unintetional data is written and load
 141:eeprom_driver.c **** 	 *  the "Page Load" command into the command register.
 142:eeprom_driver.c **** 	 */
 143:eeprom_driver.c **** 	EEPROM_FlushBuffer();
 144:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
 145:eeprom_driver.c **** 
 146:eeprom_driver.c **** 	/* Calculate address */
 147:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE)
 148:eeprom_driver.c **** 	                            |(byteAddr & (EEPROM_PAGE_SIZE-1));
 149:eeprom_driver.c **** 
 150:eeprom_driver.c **** 	/* Set address to write to. */
 151:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 152:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 153:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 154:eeprom_driver.c **** 
 155:eeprom_driver.c **** 	/* Load data to write, which triggers the loading of EEPROM page buffer. */
 156:eeprom_driver.c **** 	NVM.DATA0 = value;
 157:eeprom_driver.c **** 
 158:eeprom_driver.c **** 	/*  Issue EEPROM Atomic Write (Erase&Write) command. Load command, write
 159:eeprom_driver.c **** 	 *  the protection signature and execute command.
 160:eeprom_driver.c **** 	 */
 161:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
 162:eeprom_driver.c ****         NVM_EXEC_WRAPPER();
 163:eeprom_driver.c **** }
 164:eeprom_driver.c **** 
 165:eeprom_driver.c **** 
 166:eeprom_driver.c **** /*! \brief Read one byte from EEPROM using IO mapping.
 167:eeprom_driver.c ****  *
 168:eeprom_driver.c ****  *  This function reads one byte from EEPROM using IO-mapped access.
 169:eeprom_driver.c ****  *  Please note that the memory mapped EERPROM can not be used when using this function.
 170:eeprom_driver.c ****  *
 171:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 172:eeprom_driver.c ****  *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE.
 173:eeprom_driver.c ****  *
 174:eeprom_driver.c ****  *  \return  Byte value read from EEPROM.
 175:eeprom_driver.c ****  */
 176:eeprom_driver.c **** uint8_t EEPROM_ReadByte( uint8_t pageAddr, uint8_t byteAddr )
 177:eeprom_driver.c **** {
 402               	0,177,.LM0-.LFBB1
 403               	.LM0:
 404               	.LFBB1:
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407 0000 982F      		mov r25,r24
 408               	.L2:
 409               	.LBB33:
 410               	.LBB34:
 178:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 179:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 180:eeprom_driver.c **** 
 181:eeprom_driver.c **** 	/* Calculate address */
 182:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE)
 183:eeprom_driver.c **** 	                            |(byteAddr & (EEPROM_PAGE_SIZE-1));
 184:eeprom_driver.c **** 
 185:eeprom_driver.c **** 	/* Set address to read from. */
 186:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 187:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 188:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 189:eeprom_driver.c **** 
 190:eeprom_driver.c **** 	/* Issue EEPROM Read command. */
 191:eeprom_driver.c ****         NVM.CMD = NVM_CMD_READ_EEPROM_gc;
 192:eeprom_driver.c ****         NVM_EXEC();
 193:eeprom_driver.c **** 
 194:eeprom_driver.c **** 	return NVM.DATA0;
 195:eeprom_driver.c **** }
 196:eeprom_driver.c **** 
 197:eeprom_driver.c **** 
 198:eeprom_driver.c **** /*! \brief Wait for any NVM access to finish, including EEPROM.
 199:eeprom_driver.c ****  *
 200:eeprom_driver.c ****  *  This function is blcoking and waits for any NVM access to finish,
 201:eeprom_driver.c ****  *  including EEPROM. Use this function before any EEPROM accesses,
 202:eeprom_driver.c ****  *  if you are not certain that any previous operations are finished yet,
 203:eeprom_driver.c ****  *  like an EEPROM write.
 204:eeprom_driver.c ****  */
 205:eeprom_driver.c **** void EEPROM_WaitForNVM( void )
 206:eeprom_driver.c **** {
 207:eeprom_driver.c **** 	do {
 208:eeprom_driver.c **** 		/* Block execution while waiting for the NVM to be ready. */
 209:eeprom_driver.c **** 	} while ((NVM.STATUS & NVM_NVMBUSY_bm) == NVM_NVMBUSY_bm);
 411               	8,0,209,.LM1-.LFBB1
 412               	.LM1:
 413 0002 E0EC      		ldi r30,lo8(448)
 414 0004 F1E0      		ldi r31,hi8(448)
 415 0006 8091 CF01 		lds r24,463
 416 000a 87FD      		sbrc r24,7
 417 000c 00C0      		rjmp .L2
 418               	.LBE34:
 419               	.LBE33:
 421               	.LM2:
 422 000e 262F      		mov r18,r22
 423 0010 30E0      		ldi r19,lo8(0)
 424 0012 2F71      		andi r18,lo8(31)
 425 0014 3070      		andi r19,hi8(31)
 426 0016 892F      		mov r24,r25
 427 0018 90E0      		ldi r25,lo8(0)
 428 001a 45E0      		ldi r20,5
 429 001c 880F      	1:	lsl r24
 430 001e 991F      		rol r25
 431 0020 4A95      		dec r20
 432 0022 01F4      		brne 1b
 433 0024 282B      		or r18,r24
 434 0026 392B      		or r19,r25
 436               	.LM3:
 437 0028 2093 C001 		sts 448,r18
 439               	.LM4:
 440 002c 832F      		mov r24,r19
 441 002e 8F71      		andi r24,lo8(31)
 442 0030 8183      		std Z+1,r24
 444               	.LM5:
 445 0032 1282      		std Z+2,__zero_reg__
 447               	.LM6:
 448 0034 86E0      		ldi r24,lo8(6)
 449 0036 8287      		std Z+10,r24
 450               	.LBB35:
 451               	.LBB36:
 453               	.LM7:
 454 0038 EBEC      		ldi r30,lo8(459)
 455 003a F1E0      		ldi r31,hi8(459)
 456 003c 21E0      		ldi r18,lo8(1)
 457 003e 30E0      		ldi r19,hi8(1)
 458 0040 88ED      		ldi r24,lo8(216)
 459 0042 90E0      		ldi r25,hi8(216)
 460               	/* #APP */
 461               	 ;  65 "eeprom_driver.c" 1
 462 0044 84BF      		out 52, r24
 463 0046 2083      		st z, r18
 464               	 ;  0 "" 2
 465               	/* #NOAPP */
 466               	.LBE36:
 467               	.LBE35:
 469               	.LM8:
 470 0048 8091 C401 		lds r24,452
 471               	/* epilogue start */
 473               	.LM9:
 474 004c 0895      		ret
 479               	.Lscope1:
 481               	.global	EEPROM_WaitForNVM
 483               	EEPROM_WaitForNVM:
 485               	.LM10:
 486               	.LFBB2:
 487               	/* prologue: function */
 488               	/* frame size = 0 */
 489               	.L6:
 491               	.LM11:
 492 004e 8091 CF01 		lds r24,463
 493 0052 87FD      		sbrc r24,7
 494 0054 00C0      		rjmp .L6
 495               	/* epilogue start */
 210:eeprom_driver.c **** }
 496               	VM
 497               	.Lscope2:
 499               	.global	EEPROM_FlushBuffer
 501               	EEPROM_FlushBuffer:
 503               	.LM13:
 504               	.LFBB3:
 211:eeprom_driver.c **** 
 212:eeprom_driver.c **** 
 213:eeprom_driver.c **** /*! \brief Flush temporary EEPROM page buffer.
 214:eeprom_driver.c ****  *
 215:eeprom_driver.c ****  *  This function flushes the EEPROM page buffers. This function will cancel
 216:eeprom_driver.c ****  *  any ongoing EEPROM page buffer loading operations, if any.
 217:eeprom_driver.c ****  *  This function also works for memory mapped EEPROM access.
 218:eeprom_driver.c ****  *
 219:eeprom_driver.c ****  *  \note The EEPROM write operations will automatically flush the buffer for you.
 220:eeprom_driver.c ****  */
 221:eeprom_driver.c **** void EEPROM_FlushBuffer( void )
 222:eeprom_driver.c **** {
 505               	ue: function */
 506               	/* frame size = 0 */
 507               	.L10:
 508               	.LBB37:
 509               	.LBB38:
 511               	.LM14:
 512               		lds r24,463
 513               		sbrc r24,7
 514               		rjmp .L10
 515 0058 8091 CF01 	.LBE38:
 516 005c 87FD      	.LBE37:
 518               	.LM15:
 519               		lds r24,463
 223:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 224:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 225:eeprom_driver.c **** 
 226:eeprom_driver.c **** 	/* Flush EEPROM page buffer if necessary. */
 227:eeprom_driver.c **** 	if ((NVM.STATUS & NVM_EELOAD_bm) != 0) {
 520               	mp .L12
 522 0060 8091 CF01 	.LM16:
 523 0064 81FF      		ldi r24,lo8(54)
 524 0066 00C0      		ldi r30,lo8(448)
 228:eeprom_driver.c ****                 NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
 525               	r31,hi8(448)
 526               		std Z+10,r24
 527 0068 86E3      	.LBB39:
 528 006a E0EC      	.LBB40:
 530 006e 8287      	.LM17:
 531               		ldi r30,lo8(459)
 532               		ldi r31,hi8(459)
 533               		ldi r18,lo8(1)
 534               		ldi r19,hi8(1)
 535 0070 EBEC      		ldi r24,lo8(216)
 536 0072 F1E0      		ldi r25,hi8(216)
 537 0074 21E0      	/* #APP */
 538 0076 30E0      	 ;  65 "eeprom_driver.c" 1
 539 0078 88ED      		out 52, r24
 540 007a 90E0      		st z, r18
 541               	 ;  0 "" 2
 542               	/* #NOAPP */
 543 007c 84BF      	.L12:
 544 007e 2083      		ret
 545               	.LBE40:
 546               	.LBE39:
 548 0080 0895      	.Lscope3:
 553               	.global	EEPROM_WriteByte
 555               	EEPROM_WriteByte:
 557               	.LM18:
 558               	.LFBB4:
 559               		push r13
 560               		push r14
 561               		push r15
 562               		push r16
 563 0082 DF92      		push r17
 564 0084 EF92      	/* prologue: function */
 565 0086 FF92      	/* frame size = 0 */
 566 0088 0F93      		mov r14,r24
 567 008a 1F93      		mov r16,r22
 568               		mov r13,r20
 570 008c E82E      	.LM19:
 571 008e 062F      		call EEPROM_FlushBuffer
 573               	.LM20:
 574               		ldi r30,lo8(448)
 575 0092 0E94 0000 		ldi r31,hi8(448)
 576               		ldi r24,lo8(51)
 577               		std Z+10,r24
 579 0098 F1E0      	.LM21:
 580 009a 83E3      		ldi r17,lo8(0)
 581 009c 8287      		andi r16,lo8(31)
 582               		andi r17,hi8(31)
 583               		clr r15
 584 009e 10E0      		ldi r21,5
 585 00a0 0F71      	1:	lsl r14
 586 00a2 1070      		rol r15
 587 00a4 FF24      		dec r21
 588 00a6 55E0      		brne 1b
 589 00a8 EE0C      		or r16,r14
 590 00aa FF1C      		or r17,r15
 592 00ae 01F4      	.LM22:
 593 00b0 0E29      		st Z,r16
 595               	.LM23:
 596               		mov r24,r17
 597 00b4 0083      		andi r24,lo8(31)
 598               		std Z+1,r24
 600 00b6 812F      	.LM24:
 601 00b8 8F71      		std Z+2,__zero_reg__
 603               	.LM25:
 604               		std Z+4,r13
 606               	.LM26:
 607               		ldi r24,lo8(53)
 608 00be D482      		std Z+10,r24
 609               	.LBB41:
 610               	.LBB42:
 612 00c2 8287      	.LM27:
 613               		ldi r30,lo8(459)
 614               		ldi r31,hi8(459)
 615               		ldi r18,lo8(1)
 616               		ldi r19,hi8(1)
 617 00c4 EBEC      		ldi r24,lo8(216)
 618 00c6 F1E0      		ldi r25,hi8(216)
 619 00c8 21E0      	/* #APP */
 620 00ca 30E0      	 ;  65 "eeprom_driver.c" 1
 621 00cc 88ED      		out 52, r24
 622 00ce 90E0      		st z, r18
 623               	 ;  0 "" 2
 624               	/* epilogue start */
 625 00d0 84BF      	/* #NOAPP */
 626 00d2 2083      	.LBE42:
 627               	.LBE41:
 629               	.LM28:
 630               		pop r17
 631               		pop r16
 632               		pop r15
 633               		pop r14
 634 00d4 1F91      		pop r13
 635 00d6 0F91      		ret
 640               	.Lscope4:
 644               	.global	EEPROM_LoadByte
 646               	EEPROM_LoadByte:
 648               	.LM29:
 649               	.LFBB5:
 650               	/* prologue: function */
 229:eeprom_driver.c ****                 NVM_EXEC();
 230:eeprom_driver.c **** 	}
 231:eeprom_driver.c **** }
 232:eeprom_driver.c **** 
 233:eeprom_driver.c **** 
 234:eeprom_driver.c **** /*! \brief Load single byte into temporary page buffer.
 235:eeprom_driver.c ****  *
 236:eeprom_driver.c ****  *  This function loads one byte into the temporary EEPROM page buffers.
 237:eeprom_driver.c ****  *  If memory mapped EEPROM is enabled, this function will not work.
 238:eeprom_driver.c ****  *  Make sure that the buffer is flushed before starting to load bytes.
 239:eeprom_driver.c ****  *  Also, if multiple bytes are loaded into the same location, they will
 240:eeprom_driver.c ****  *  be ANDed together, thus 0x55 and 0xAA will result in 0x00 in the buffer.
 241:eeprom_driver.c ****  *
 242:eeprom_driver.c ****  *  \note Only one page buffer exist, thus only one page can be loaded with
 243:eeprom_driver.c ****  *        data and programmed into one page. If data needs to be written to
 244:eeprom_driver.c ****  *        different pages, the loading and writing needs to be repeated.
 245:eeprom_driver.c ****  *
 246:eeprom_driver.c ****  *  \param  byteAddr  EEPROM Byte address, between 0 and EEPROM_PAGE_SIZE.
 247:eeprom_driver.c ****  *  \param  value     Byte value to write to buffer.
 248:eeprom_driver.c ****  */
 249:eeprom_driver.c **** void EEPROM_LoadByte( uint8_t byteAddr, uint8_t value )
 250:eeprom_driver.c **** {
 651               	8)
 652               		lds r24,463
 653               		sbrc r24,7
 654               		rjmp .L17
 655               	.LBE44:
 656 00e0 982F      	.LBE43:
 658               	.LM31:
 659               		ldi r24,lo8(51)
 660               		std Z+10,r24
 662 00e2 E0EC      	.LM32:
 663 00e4 F1E0      		sts 448,r25
 665 00ea 87FD      	.LM33:
 666 00ec 00C0      		std Z+1,__zero_reg__
 668               	.LM34:
 251:eeprom_driver.c **** 	/* Wait until NVM is not busy and prepare NVM command.*/
 252:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 253:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
 669               	g__
 671 00ee 83E3      	.LM35:
 672 00f0 8287      		std Z+4,r22
 254:eeprom_driver.c **** 
 255:eeprom_driver.c **** 	/* Set address. */
 256:eeprom_driver.c **** 	NVM.ADDR0 = byteAddr & 0xFF;
 673               	pilogue start */
 675 00f2 9093 C001 	.LM36:
 257:eeprom_driver.c **** 	NVM.ADDR1 = 0x00;
 676               	t
 678 00f6 1182      	.Lscope5:
 258:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 679               	tabs	"EEPROM_LoadPage:F(0,15)",36,0,0,EEPROM_LoadPage
 681 00f8 1282      	.global	EEPROM_LoadPage
 259:eeprom_driver.c **** 
 260:eeprom_driver.c **** 	/* Set data, which triggers loading of EEPROM page buffer. */
 261:eeprom_driver.c **** 	NVM.DATA0 = value;
 682               	ype	EEPROM_LoadPage, @function
 683               	EEPROM_LoadPage:
 685               	.LM37:
 262:eeprom_driver.c **** }
 686               	B6:
 687               	/* prologue: function */
 688 00fc 0895      	/* frame size = 0 */
 689               		movw r26,r24
 690               	.L21:
 691               	.LBB45:
 692               	.LBB46:
 694               	.LM38:
 695               		ldi r30,lo8(448)
 263:eeprom_driver.c **** 
 264:eeprom_driver.c **** 
 265:eeprom_driver.c **** /*! \brief Load entire page into temporary EEPROM page buffer.
 266:eeprom_driver.c ****  *
 267:eeprom_driver.c ****  *  This function loads an entire EEPROM page from an SRAM buffer to
 268:eeprom_driver.c ****  *  the EEPROM page buffers. Please note that the memory mapped EERPROM can not be used when using 
 269:eeprom_driver.c ****  *  Make sure that the buffer is flushed before
 270:eeprom_driver.c ****  *  starting to load bytes.
 271:eeprom_driver.c ****  *
 272:eeprom_driver.c ****  *  \note Only the lower part of the address is used to address the buffer.
 273:eeprom_driver.c ****  *        Therefore, no address parameter is needed. In the end, the data
 274:eeprom_driver.c ****  *        is written to the EEPROM page given by the address parameter to the
 275:eeprom_driver.c ****  *        EEPROM write page operation.
 276:eeprom_driver.c ****  *
 277:eeprom_driver.c ****  *  \param  values   Pointer to SRAM buffer containing an entire page.
 278:eeprom_driver.c ****  */
 279:eeprom_driver.c **** void EEPROM_LoadPage( const uint8_t * values )
 280:eeprom_driver.c **** {
 696               	i8(448)
 697               		lds r24,463
 698               		sbrc r24,7
 699               		rjmp .L21
 700               	.LBE46:
 701 00fe DC01      	.LBE45:
 703               	.LM39:
 704               		ldi r24,lo8(51)
 705               		std Z+10,r24
 707 0100 E0EC      	.LM40:
 708 0102 F1E0      		std Z+1,__zero_reg__
 710 0108 87FD      	.LM41:
 711 010a 00C0      		std Z+2,__zero_reg__
 712               		ldi r25,lo8(0)
 713               	.L22:
 281:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 282:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 283:eeprom_driver.c **** 	NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
 714               	,0,293,.LM42-.LFBB6
 715               	.LM42:
 716 010c 83E3      		sts 448,r25
 284:eeprom_driver.c **** 
 285:eeprom_driver.c **** 	/*  Set address to zero, as only the lower bits matters. ADDR0 is
 286:eeprom_driver.c **** 	 *  maintained inside the loop below.
 287:eeprom_driver.c **** 	 */
 288:eeprom_driver.c **** 	NVM.ADDR1 = 0x00;
 718               	3:
 719               		ld r24,X+
 720 0110 1182      		std Z+4,r24
 289:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 721               	tabn	68,0,292,.LM44-.LFBB6
 722               	.LM44:
 723 0112 1282      		subi r25,lo8(-(1))
 724 0114 90E0      		cpi r25,lo8(32)
 725               		brne .L22
 726               	/* epilogue start */
 290:eeprom_driver.c **** 
 291:eeprom_driver.c **** 	/* Load multible bytes into page buffer. */
 292:eeprom_driver.c **** 	for (uint8_t i = 0; i < EEPROM_PAGE_SIZE; ++i) {
 293:eeprom_driver.c **** 		NVM.ADDR0 = i;
 727               	:
 729 0116 9093 C001 	.LM45:
 294:eeprom_driver.c **** 		NVM.DATA0 = *values;
 730               	t
 735               	.Lscope6:
 738 0122 01F4      	.global	EEPROM_AtomicWritePage
 740               	EEPROM_AtomicWritePage:
 295:eeprom_driver.c **** 		++values;
 296:eeprom_driver.c **** 	}
 297:eeprom_driver.c **** }
 741               	0,312,.LM46-.LFBB7
 742               	.LM46:
 743 0124 0895      	.LFBB7:
 744               	/* prologue: function */
 745               	/* frame size = 0 */
 746               		mov r25,r24
 747               	.L27:
 748               	.LBB48:
 749               	.LBB49:
 751               	.LM47:
 752               		ldi r30,lo8(448)
 753               		ldi r31,hi8(448)
 298:eeprom_driver.c **** 
 299:eeprom_driver.c **** /*! \brief Write already loaded page into EEPROM.
 300:eeprom_driver.c ****  *
 301:eeprom_driver.c ****  *  This function writes the contents of an already loaded EEPROM page
 302:eeprom_driver.c ****  *  buffer into EEPROM memory.
 303:eeprom_driver.c ****  *
 304:eeprom_driver.c ****  *  As this is an atomic write, the page in EEPROM will be erased
 305:eeprom_driver.c ****  *  automatically before writing. Note that only the page buffer locations
 306:eeprom_driver.c ****  *  that have been loaded will be used when writing to EEPROM. Page buffer
 307:eeprom_driver.c ****  *  locations that have not been loaded will be left untouched in EEPROM.
 308:eeprom_driver.c ****  *
 309:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 310:eeprom_driver.c ****  */
 311:eeprom_driver.c **** void EEPROM_AtomicWritePage( uint8_t pageAddr )
 312:eeprom_driver.c **** {
 754               		sbrc r24,7
 755               		rjmp .L27
 756               	.LBE49:
 757               	.LBE48:
 759 0126 982F      	.LM48:
 760               		mov r24,r25
 761               		ldi r25,lo8(0)
 762               		ldi r22,5
 763               	1:	lsl r24
 764               		rol r25
 765 0128 E0EC      		dec r22
 766 012a F1E0      		brne 1b
 768 0130 87FD      	.LM49:
 769 0132 00C0      		sts 448,r24
 771               	.LM50:
 313:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 314:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 315:eeprom_driver.c **** 
 316:eeprom_driver.c **** 	/* Calculate page address */
 317:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE);
 772               	 r24,lo8(31)
 773               		std Z+1,r24
 775 0136 90E0      	.LM51:
 776 0138 65E0      		std Z+2,__zero_reg__
 778 013c 991F      	.LM52:
 779 013e 6A95      		ldi r24,lo8(53)
 780 0140 01F4      		std Z+10,r24
 318:eeprom_driver.c **** 
 319:eeprom_driver.c **** 	/* Set address. */
 320:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 781               	M49:
 782               		sts 448,r24
 321:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 784               	50:
 785               		mov r24,r25
 786 0146 892F      		andi r24,lo8(31)
 787 0148 8F71      		std Z+1,r24
 322:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 789               	4,r25
 790               		ldi r25,lo8(0)
 791 014c 1282      		ldi r22,5
 323:eeprom_driver.c **** 
 324:eeprom_driver.c **** 	/* Issue EEPROM Atomic Write (Erase&Write) command. */
 325:eeprom_driver.c ****         NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
 792               	lsl r24
 793               		rol r25
 794 014e 85E3      		dec r22
 795 0150 8287      		brne 1b
 797               	.LM49:
 798               		sts 448,r24
 800 0152 EBEC      	.LM50:
 801 0154 F1E0      		mov r24,r25
 802 0156 21E0      		andi r24,lo8(31)
 803 0158 30E0      		std Z+1,r24
 805 015c 90E0      	.LM51:
 806               		std Z+2,__zero_reg__
 808 015e 84BF      	.LM52:
 809 0160 2083      		ldi r24,lo8(53)
 810               		std Z+10,r24
 811               	.LBB50:
 812               	.LBB51:
 814               	.LM53:
 326:eeprom_driver.c ****         NVM_EXEC();
 327:eeprom_driver.c **** }
 815               	r31,hi8(459)
 816               		ldi r18,lo8(1)
 817 0162 0895      		ldi r19,hi8(1)
 818               		ldi r24,lo8(216)
 819               		ldi r25,hi8(216)
 820               	/* #APP */
 821               	 ;  65 "eeprom_driver.c" 1
 822               		out 52, r24
 823               		st z, r18
 824               	 ;  0 "" 2
 825               	/* epilogue start */
 826               	/* #NOAPP */
 827               	.LBE51:
 328:eeprom_driver.c **** 
 329:eeprom_driver.c **** 
 330:eeprom_driver.c **** /*! \brief Erase EEPROM page.
 331:eeprom_driver.c ****  *
 332:eeprom_driver.c ****  *  This function erases one EEPROM page, so that every location reads 0xFF.
 333:eeprom_driver.c ****  *
 334:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 335:eeprom_driver.c ****  */
 336:eeprom_driver.c **** void EEPROM_ErasePage( uint8_t pageAddr )
 337:eeprom_driver.c **** {
 828               	8(459)
 829               		ldi r31,hi8(459)
 830               		ldi r18,lo8(1)
 831               		ldi r19,hi8(1)
 832               		ldi r24,lo8(216)
 833 0164 982F      		ldi r25,hi8(216)
 834               	/* #APP */
 835               	 ;  65 "eeprom_driver.c" 1
 836               		out 52, r24
 837               		st z, r18
 838               	 ;  0 "" 2
 839 0166 E0EC      	/* epilogue start */
 840 0168 F1E0      	/* #NOAPP */
 841 016a 8091 CF01 	.LBE51:
 842 016e 87FD      	.LBE50:
 844               	.LM54:
 845               		ret
 338:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 339:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 340:eeprom_driver.c **** 
 341:eeprom_driver.c **** 	/* Calculate page address */
 342:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE);
 846               	1)
 847               		ldi r24,lo8(216)
 848 0172 892F      		ldi r25,hi8(216)
 849 0174 90E0      	/* #APP */
 850 0176 75E0      	 ;  65 "eeprom_driver.c" 1
 851 0178 880F      		out 52, r24
 852 017a 991F      		st z, r18
 853 017c 7A95      	 ;  0 "" 2
 854 017e 01F4      	/* epilogue start */
 343:eeprom_driver.c **** 
 344:eeprom_driver.c **** 	/* Set address. */
 345:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 855               	FBB7
 856               	.LM53:
 857 0180 8093 C001 		ldi r30,lo8(459)
 346:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 858               	24,lo8(31)
 859               		std Z+1,r24
 861 0186 8F71      	.LM51:
 862 0188 8183      		std Z+2,__zero_reg__
 347:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 863               	5
 864               	1:	lsl r24
 865 018a 1282      		rol r25
 348:eeprom_driver.c **** 
 349:eeprom_driver.c **** 	/* Issue EEPROM Erase command. */
 350:eeprom_driver.c ****         NVM.CMD = NVM_CMD_ERASE_EEPROM_PAGE_gc;
 866               	c r22
 867               		brne 1b
 869 018e 8287      	.LM49:
 870               		sts 448,r24
 872               	.LM50:
 873               		mov r24,r25
 874 0190 EBEC      		andi r24,lo8(31)
 875 0192 F1E0      		std Z+1,r24
 877 0196 30E0      	.LM51:
 878 0198 88ED      		std Z+2,__zero_reg__
 880               	.LM52:
 881               		ldi r24,lo8(53)
 882 019c 84BF      		std Z+10,r24
 883 019e 2083      	.LBB50:
 884               	.LBB51:
 886               	.LM53:
 887               		ldi r30,lo8(459)
 888               		ldi r31,hi8(459)
 351:eeprom_driver.c ****         NVM_EXEC_WRAPPER();
 352:eeprom_driver.c **** }
 889               	9,hi8(1)
 890               		ldi r24,lo8(216)
 891 01a0 0895      		ldi r25,hi8(216)
 892               	/* #APP */
 893               	 ;  65 "eeprom_driver.c" 1
 894               		out 52, r24
 895               		st z, r18
 896               	 ;  0 "" 2
 897               	/* epilogue start */
 898               	/* #NOAPP */
 899               	.LBE51:
 900               	.LBE50:
 353:eeprom_driver.c **** 
 354:eeprom_driver.c **** 
 355:eeprom_driver.c **** /*! \brief Write (without erasing) EEPROM page.
 356:eeprom_driver.c ****  *
 357:eeprom_driver.c ****  *  This function writes the contents of an already loaded EEPROM page
 358:eeprom_driver.c ****  *  buffer into EEPROM memory.
 359:eeprom_driver.c ****  *
 360:eeprom_driver.c ****  *  As this is a split write, the page in EEPROM will _not_ be erased
 361:eeprom_driver.c ****  *  before writing.
 362:eeprom_driver.c ****  *
 363:eeprom_driver.c ****  *  \param  pageAddr  EEPROM Page address, between 0 and EEPROM_SIZE/EEPROM_PAGE_SIZE
 364:eeprom_driver.c ****  */
 365:eeprom_driver.c **** void EEPROM_SplitWritePage( uint8_t pageAddr )
 366:eeprom_driver.c **** {
 902               	
 903               		ldi r19,hi8(1)
 904               		ldi r24,lo8(216)
 905               		ldi r25,hi8(216)
 906               	/* #APP */
 907 01a2 982F      	 ;  65 "eeprom_driver.c" 1
 908               		out 52, r24
 909               		st z, r18
 910               	 ;  0 "" 2
 911               	/* epilogue start */
 912               	/* #NOAPP */
 913 01a4 E0EC      	.LBE51:
 914 01a6 F1E0      	.LBE50:
 916 01ac 87FD      	.LM54:
 917 01ae 00C0      		ret
 367:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 368:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 369:eeprom_driver.c **** 
 370:eeprom_driver.c **** 	/* Calculate page address */
 371:eeprom_driver.c **** 	uint16_t address = (uint16_t)(pageAddr*EEPROM_PAGE_SIZE);
 920               	 z, r18
 921               	 ;  0 "" 2
 922 01b0 892F      	/* epilogue start */
 923 01b2 90E0      	/* #NOAPP */
 924 01b4 A5E0      	.LBE51:
 925 01b6 880F      	.LBE50:
 927 01ba AA95      	.LM54:
 928 01bc 01F4      		ret
 372:eeprom_driver.c **** 
 373:eeprom_driver.c **** 	/* Set address. */
 374:eeprom_driver.c **** 	NVM.ADDR0 = address & 0xFF;
 929               	1)
 930               		ldi r24,lo8(216)
 931 01be 8093 C001 		ldi r25,hi8(216)
 375:eeprom_driver.c **** 	NVM.ADDR1 = (address >> 8) & 0x1F;
 932               	68,0,325,.LM52-.LFBB7
 933               	.LM52:
 934 01c2 892F      		ldi r24,lo8(53)
 935 01c4 8F71      		std Z+10,r24
 936 01c6 8183      	.LBB50:
 376:eeprom_driver.c **** 	NVM.ADDR2 = 0x00;
 937               	 448,r24
 939 01c8 1282      	.LM50:
 377:eeprom_driver.c **** 
 378:eeprom_driver.c **** 	/* Issue EEPROM Split Write command. */
 379:eeprom_driver.c ****         NVM.CMD = NVM_CMD_WRITE_EEPROM_PAGE_gc;
 940               	v r24,r25
 941               		andi r24,lo8(31)
 942 01ca 84E3      		std Z+1,r24
 944               	.LM51:
 945               		std Z+2,__zero_reg__
 947               	.LM52:
 948 01ce EBEC      		ldi r24,lo8(53)
 949 01d0 F1E0      		std Z+10,r24
 950 01d2 21E0      	.LBB50:
 951 01d4 30E0      	.LBB51:
 953 01d8 90E0      	.LM53:
 954               		ldi r30,lo8(459)
 955               		ldi r31,hi8(459)
 956 01da 84BF      		ldi r18,lo8(1)
 957 01dc 2083      		ldi r19,hi8(1)
 958               		ldi r24,lo8(216)
 959               		ldi r25,hi8(216)
 960               	/* #APP */
 961               	 ;  65 "eeprom_driver.c" 1
 962               		out 52, r24
 380:eeprom_driver.c ****         NVM_EXEC_WRAPPER();
 381:eeprom_driver.c **** }
 963               	0,r24
 964               	.LBB50:
 965 01de 0895      	.LBB51:
 967               	.LM53:
 968               		ldi r30,lo8(459)
 969               		ldi r31,hi8(459)
 970               		ldi r18,lo8(1)
 971               		ldi r19,hi8(1)
 972               		ldi r24,lo8(216)
 973               		ldi r25,hi8(216)
 974               	/* #APP */
 382:eeprom_driver.c **** 
 383:eeprom_driver.c **** /*! \brief Erase entire EEPROM memory.
 384:eeprom_driver.c ****  *
 385:eeprom_driver.c ****  *  This function erases the entire EEPROM memory block to 0xFF.
 386:eeprom_driver.c ****  */
 387:eeprom_driver.c **** void EEPROM_EraseAll( void )
 388:eeprom_driver.c **** {
 975               	52-.LFBB7
 976               	.LM52:
 977               		ldi r24,lo8(53)
 978               		std Z+10,r24
 979               	.LBB50:
 980               	.LBB51:
 982               	.LM53:
 983               		ldi r30,lo8(459)
 984               		ldi r31,hi8(459)
 985 01e0 8091 CF01 		ldi r18,lo8(1)
 986 01e4 87FD      		ldi r19,hi8(1)
 987 01e6 00C0      		ldi r24,lo8(216)
 988               		ldi r25,hi8(216)
 989               	/* #APP */
 389:eeprom_driver.c **** 	/* Wait until NVM is not busy. */
 390:eeprom_driver.c **** 	EEPROM_WaitForNVM();
 391:eeprom_driver.c **** 
 392:eeprom_driver.c **** 	/* Issue EEPROM Erase All command. */
 393:eeprom_driver.c ****         NVM.CMD = NVM_CMD_ERASE_EEPROM_gc;
 990               	52-.LFBB7
 991               	.LM52:
 992 01e8 80E3      		ldi r24,lo8(53)
 993 01ea E0EC      		std Z+10,r24
 994 01ec F1E0      	.LBB50:
 995 01ee 8287      	.LBB51:
 997               	.LM53:
 998               		ldi r30,lo8(459)
 999               		ldi r31,hi8(459)
 1000 01f0 EBEC      		ldi r18,lo8(1)
 1001 01f2 F1E0      		ldi r19,hi8(1)
 1002 01f4 21E0      		ldi r24,lo8(216)
 1003 01f6 30E0      		ldi r25,hi8(216)
 1004 01f8 88ED      	/* #APP */
 1005 01fa 90E0      	 ;  65 "eeprom_driver.c" 1
 1006               		out 52, r24
 1007               		st z, r18
 1008 01fc 84BF      	 ;  0 "" 2
 1009 01fe 2083      	/* epilogue start */
 1010               	/* #NOAPP */
 1011               	.LBE51:
 1012               	.LBE50:
 1014               	.LM54:
 394:eeprom_driver.c ****         NVM_EXEC_WRAPPER();
 395:eeprom_driver.c **** }
 1015               	9,hi8(1)
 1016               		ldi r24,lo8(216)
 1017 0200 0895      		ldi r25,hi8(216)
 1018               	/* #APP */
 1019               	 ;  65 "eeprom_driver.c" 1
 1020               		out 52, r24
 1021               		st z, r18
DEFINED SYMBOLS
                            *ABS*:00000000 eeprom_driver.c
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:2      *ABS*:0000003f __SREG__
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:3      *ABS*:0000003e __SP_H__
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:4      *ABS*:0000003d __SP_L__
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:5      *ABS*:00000034 __CCP__
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:7      *ABS*:00000001 __zero_reg__
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:401    .text:00000000 EEPROM_ReadByte
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:483    .text:0000004e EEPROM_WaitForNVM
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:504    .text:00000058 EEPROM_FlushBuffer
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:559    .text:00000082 EEPROM_WriteByte
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:650    .text:000000e0 EEPROM_LoadByte
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:695    .text:000000fe EEPROM_LoadPage
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:753    .text:00000126 EEPROM_AtomicWritePage
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:827    .text:00000164 EEPROM_ErasePage
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:901    .text:000001a2 EEPROM_SplitWritePage
C:\Users\tlauwers\AppData\Local\Temp/ccHw33wd.s:974    .text:000001e0 EEPROM_EraseAll

NO UNDEFINED SYMBOLS
